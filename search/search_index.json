{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Minimal, modern embedded V8 for Python.</p> <p></p> <p>Full documentation.</p>"},{"location":"#in-brief","title":"In brief","text":"<ul> <li>Latest ECMAScript support</li> <li>Web Assembly support</li> <li>Unicode support</li> <li>Thread safe</li> <li>Re-usable contexts</li> </ul> <p>MiniRacer can be easily used by Django or Flask projects to minify assets, run babel or WASM modules.</p> <p>PyMiniRacer was created by Sqreen, and originally lived at https://github.com/sqreen/PyMiniRacer with the PyPI package <code>py-mini-racer</code>. After dicussion with the original Sqreen team, I have created a new official home for at https://github.com/bpcreech/PyMiniRacer with a new PyPI package <code>mini-racer</code> (note: no <code>py-</code>). See the full history for more.</p>"},{"location":"#examples","title":"Examples","text":"<p>MiniRacer is straightforward to use:</p> <pre><code>    $ pip install mini-racer\n</code></pre> <p>and then:</p> <pre><code>    $ python3\n    &gt;&gt;&gt; from py_mini_racer import MiniRacer\n    &gt;&gt;&gt; ctx = MiniRacer()\n    &gt;&gt;&gt; ctx.eval(\"1+1\")\n    2\n    &gt;&gt;&gt; ctx.eval(\"var x = {company: 'Sqreen'}; x.company\")\n    'Sqreen'\n    &gt;&gt;&gt; print(ctx.eval(\"'\u2764'\"))\n    \u2764\n    &gt;&gt;&gt; ctx.eval(\"var fun = () =&gt; ({ foo: 1 });\")\n</code></pre> <p>Variables are kept inside of a context:</p> <pre><code>    &gt;&gt;&gt; ctx.eval(\"x.company\")\n    'Sqreen'\n</code></pre> <p>You can evaluate whole scripts within JavaScript, or define and return JavaScript function objects and call them from Python (new in v0.11.0):</p> <pre><code>    &gt;&gt;&gt; square = ctx.eval(\"a =&gt; a*a\")\n    &gt;&gt;&gt; square(4)\n    16\n</code></pre> <p>JavaScript Objects and Arrays are modeled in Python as dictionaries and lists (or, more precisely, <code>MutableMapping</code> and <code>MutableSequence</code> instances), respectively (new in v0.11.0):</p> <pre><code>    &gt;&gt;&gt; obj = ctx.eval(\"var obj = {'foo': 'bar'}; obj\")\n    &gt;&gt;&gt; obj[\"foo\"]\n    'bar'\n    &gt;&gt;&gt; list(obj.keys())\n    ['foo']\n    &gt;&gt;&gt; arr = ctx.eval(\"var arr = ['a', 'b']; arr\")\n    &gt;&gt;&gt; arr[1]\n    'b'\n    &gt;&gt;&gt; 'a' in arr\n    True\n    &gt;&gt;&gt; arr.append(obj)\n    &gt;&gt;&gt; ctx.eval(\"JSON.stringify(arr)\")\n    '[\"a\",\"b\",{\"foo\":\"bar\"}]'\n</code></pre> <p>Meanwhile, <code>call</code> uses JSON to transfer data between JavaScript and Python, and converts data in bulk:</p> <pre><code>    &gt;&gt;&gt; ctx.call(\"fun\")\n    {'foo': 1}\n</code></pre> <p>Composite values are serialized using JSON. Use a custom JSON encoder when sending non-JSON encodable parameters:</p> <pre><code>    import json\n\n    from datetime import datetime\n\n    class CustomEncoder(json.JSONEncoder):\n\n            def default(self, obj):\n                if isinstance(obj, datetime):\n                    return obj.isoformat()\n\n                return json.JSONEncoder.default(self, obj)\n</code></pre> <pre><code>    &gt;&gt;&gt; ctx.eval(\"var f = function(args) { return args; }\")\n    &gt;&gt;&gt; ctx.call(\"f\", datetime.now(), encoder=CustomEncoder)\n    '2017-03-31T16:51:02.474118'\n</code></pre> <p>MiniRacer is ES6 capable:</p> <pre><code>    &gt;&gt;&gt; ctx.execute(\"[1,2,3].includes(5)\")\n    False\n</code></pre> <p>JavaScript <code>null</code> and <code>undefined</code> are modeled in Python as <code>None</code> and <code>JSUndefined</code>, respectively:</p> <pre><code>    &gt;&gt;&gt; list(ctx.eval(\"[null, undefined]\"))\n    [None, JSUndefined]\n</code></pre> <p>You can prevent runaway execution in synchronous code using the <code>timeout_sec</code> parameter:</p> <pre><code>    &gt;&gt;&gt; ctx.eval('while (true) {}', timeout_sec=2)\n    # Spins for 2 seconds and then emits a traceback ending with...\n        raise JSTimeoutException from e\n    py_mini_racer._exc.JSTimeoutException: JavaScript was terminated by timeout\n    &gt;&gt;&gt; func = ctx.eval('() =&gt; {while (true) {}}')\n    &gt;&gt;&gt; func(timeout_sec=2)\n    # Spins for 2 seconds and then emits a traceback ending with...\n        raise JSTimeoutException from e\n    py_mini_racer._exc.JSTimeoutException: JavaScript was terminated by timeout\n</code></pre> <p>MiniRacer supports asynchronous execution using JS <code>Promise</code> instances (new in v0.10.0):</p> <pre><code>    &gt;&gt;&gt; promise = ctx.eval(\n    ...     \"new Promise((res, rej) =&gt; setTimeout(() =&gt; res(42), 10000))\")\n    &gt;&gt;&gt; promise.get()  # blocks for 10 seconds, and then:\n    42\n</code></pre> <p>For more deterministic cleanup behavior, we strongly recommend allocating a MiniRacer from a context manager (new in v0.14.0):</p> <pre><code>    &gt;&gt;&gt; from py_mini_racer import mini_racer\n    &gt;&gt;&gt; with mini_racer() as ctx:\n    ...     print(ctx.eval(\"Array.from('foobar').reverse().join('')\"))\n    raboof\n</code></pre> <p>MiniRacer uses <code>asyncio</code> internally to manage V8. Both <code>MiniRacer()</code> and the <code>mini_racer()</code> context manager will capture the currently-running event loop, or you can specify a loop explicitly, and in non-async contexts, <code>MiniRacer</code> will launch its own event loop with its own background thread to service it. (new in v0.14.0)</p> <pre><code>    &gt;&gt;&gt; from py_mini_racer import MiniRacer, mini_racer\n    &gt;&gt;&gt; ctx = MiniRacer()  # launches a new event loop in a new thread\n    &gt;&gt;&gt; with mini_racer() as ctx:  # same: launches a new event loop in a new thread\n    ...     pass\n    ...\n    &gt;&gt;&gt; async def demo():\n    ...     with mini_racer() as ctx:  # reuses the running event loop\n    ...         pass\n    ...\n    &gt;&gt;&gt; import asyncio\n    &gt;&gt;&gt; asyncio.run(demo())\n    &gt;&gt;&gt; my_loop = asyncio.new_event_loop()\n    &gt;&gt;&gt; with mini_racer(my_loop) as ctx:  # uses the specified event loop\n    ...     pass\n</code></pre> <p>When calling into MiniRacer from async code, you must await promises using <code>await</code> (instead of <code>promise.get()</code>):</p> <pre><code>    % python -m asyncio\n    &gt;&gt;&gt; from py_mini_racer import mini_racer\n    &gt;&gt;&gt; with mini_racer() as ctx:\n    ...     promise = ctx.eval(\n    ...         \"new Promise((res, rej) =&gt; setTimeout(() =&gt; res(42), 10000))\")\n    ...     print(await promise)  # yields for 10 seconds, and then:\n    ...\n    42\n</code></pre> <p><code>MiniRacer</code> does not support the <code>timeout_sec</code> parameter in async evaluation. Instead request a cancelable evaluation and use a construct like <code>asyncio.wait_for</code>:</p> <pre><code>    % python -m asyncio\n    &gt;&gt;&gt; from py_mini_racer import mini_racer\n    &gt;&gt;&gt; with mini_racer() as ctx:\n    ...     # Use eval_cancelable(...), which has async semantics:\n    ...     await asyncio.wait_for(ctx.eval_cancelable('while (true) {}'), timeout=2)\n    # Spins for 2 seconds and then emits a traceback ending with...\n        raise TimeoutError from exc_val\n    TimeoutError\n    &gt;&gt;&gt; with mini_racer() as ctx:\n    ...     func = ctx.eval('() =&gt; {while (true) {}}')\n    ...     # Upgrade func using .cancelable(), which introduces async semantics:\n    ...     cancelable_func = func.cancelable()\n    ...     await asyncio.wait_for(cancelable_func(), timeout=2)\n    # Spins for 2 seconds and then emits a traceback ending with...\n        raise TimeoutError from exc_val\n    TimeoutError\n</code></pre> <p>You can install callbacks from JavaScript to Python (new in v0.12.0). Only async callbacks are supported:</p> <pre><code>    % python -m asyncio\n    &gt;&gt;&gt; from py_mini_racer import mini_racer\n    &gt;&gt;&gt; async def read_file(fn):\n    ...     with open(fn) as f:  # (or aiofiles would be even better here)\n    ...         return f.read()\n    ...\n    &gt;&gt;&gt; with mini_racer() as ctx:\n    ...     async with ctx.wrap_py_function(read_file) as jsfunc:\n    ...         # \"Install\" our (async) JS function on the global \"this\" object:\n    ...         ctx.eval('this')['read_file'] = jsfunc\n    ...         d = await ctx.eval('read_file(\"/usr/share/dict/words\")')\n    ...         print(d.split()[0:10])\n    ['A', 'AA', 'AAA', \"AA's\", 'AB', 'ABC', \"ABC's\", 'ABCs', 'ABM', \"ABM's\"]\n</code></pre> <p>Note that adding Python callbacks may degrade the security properties of PyMiniRacer! See PyMiniRacer's security goals.</p> <p>MiniRacer supports the ECMA <code>Intl</code> API:</p> <pre><code>    # Indonesian dates!\n    &gt;&gt;&gt; ctx.eval('Intl.DateTimeFormat([\"ban\", \"id\"]).format(new Date())')\n    '16/3/2024'\n</code></pre> <p>V8 heap information can be retrieved:</p> <pre><code>    &gt;&gt;&gt; ctx.heap_stats()\n    {'total_physical_size': 1613896,\n     'used_heap_size': 1512520,\n     'total_heap_size': 3997696,\n     'total_heap_size_executable': 3145728,\n     'heap_size_limit': 1501560832}\n</code></pre> <p>A WASM example is available in the <code>tests</code>.</p>"},{"location":"#compatibility","title":"Compatibility","text":"<p>PyMiniRacer is compatible with Python 3.10-3.14 and is based on <code>ctypes</code>.</p> <p>PyMiniRacer is distributed using wheels on PyPI. The wheels are intended to provide compatibility with:</p> OS x86_64 aarch64 macOS \u2265 10.9 \u2713 \u2713 Windows \u2265 10 \u2713 \u2713 Ubuntu \u2265 20.04 \u2713 \u2713 Debian \u2265 11 \u2713 \u2713 RHEL \u2265 9 \u2713 \u2713 other Linuxes with glibc \u2265 2.27 \u2713 \u2713 Alpine \u2265 3.19 \u2713 \u2713 other Linux with musl \u2265 1.2 \u2713 \u2713 <p>In order to run on Alpine you must install <code>gcompat</code> and run with <code>LD_PRELOAD=\"/lib/libgcompat.so.0\"</code>.</p> <p>If you have a up-to-date pip and it doesn't use a wheel, you might have an environment for which no wheel is built. Please open an issue.</p>"},{"location":"#developing-and-releasing-pyminiracer","title":"Developing and releasing PyMiniRacer","text":"<p>See the contribution guide.</p>"},{"location":"#credits","title":"Credits","text":"<p>Built with love by Sqreen.</p> <p>PyMiniRacer launch was described in <code>this blog post</code>.</p> <p>PyMiniRacer is inspired by mini_racer, built for the Ruby world by Sam Saffron.</p> <p>In 2024, PyMiniRacer was revived, and adopted by Ben Creech. Upon discussion with the original Sqreen authors, we decided to re-launch PyMiniRacer as a fork under https://github.com/bpcreech/PyMiniRacer and https://pypi.org/project/mini-racer/.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#py_mini_racer.CancelableJSFunction","title":"<code>CancelableJSFunction</code>","text":"<p>               Bases: <code>JSMappedObject</code></p> <p>JavaScript function.</p> <p>This type is returned by JSFunction.cancelable().</p> <p>You can call this object from Python, passing in positional args to match what the JavaScript function expects. Calls on the Python side are async, regardless of whether the underlying JS function is async (so a call to an async JS function will return a JSPromise, requiring a \"double await\" in Python to get the result).</p> Source code in <code>src/py_mini_racer/_types.py</code> <pre><code>class CancelableJSFunction(JSMappedObject):\n    \"\"\"JavaScript function.\n\n    This type is returned by JSFunction.cancelable().\n\n    You can call this object from Python, passing in positional args to match what the\n    JavaScript function expects. Calls on the Python side are async, regardless of\n    whether the underlying JS function is async (so a call to an async JS function will\n    return a JSPromise, requiring a \"double await\" in Python to get the result).\n    \"\"\"\n\n    async def __call__(\n        self,\n        *args: PythonJSConvertedTypes,\n        this: JSObject | JSUndefinedType = JSUndefined,\n    ) -&gt; PythonJSConvertedTypes:\n        raise NotImplementedError\n</code></pre>"},{"location":"api/#py_mini_racer.JSArray","title":"<code>JSArray</code>","text":"<p>               Bases: <code>MutableSequence['PythonJSConvertedTypes']</code>, <code>JSObject</code></p> <p>JavaScript array.</p> <p>Has Pythonic MutableSequence methods (e.g., <code>insert()</code>, <code>__getitem__()</code>, ...).</p> Source code in <code>src/py_mini_racer/_types.py</code> <pre><code>class JSArray(MutableSequence[\"PythonJSConvertedTypes\"], JSObject):\n    \"\"\"JavaScript array.\n\n    Has Pythonic MutableSequence methods (e.g., `insert()`, `__getitem__()`, ...).\n    \"\"\"\n</code></pre>"},{"location":"api/#py_mini_racer.JSArrayIndexError","title":"<code>JSArrayIndexError</code>","text":"<p>               Bases: <code>IndexError</code>, <code>MiniRacerBaseException</code></p> <p>Invalid index into a JSArray.</p> Source code in <code>src/py_mini_racer/_exc.py</code> <pre><code>class JSArrayIndexError(IndexError, MiniRacerBaseException):\n    \"\"\"Invalid index into a JSArray.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(\"JSArray deletion out of range\")\n</code></pre>"},{"location":"api/#py_mini_racer.JSEvalException","title":"<code>JSEvalException</code>","text":"<p>               Bases: <code>MiniRacerBaseException</code></p> <p>JavaScript could not be executed.</p> Source code in <code>src/py_mini_racer/_exc.py</code> <pre><code>class JSEvalException(MiniRacerBaseException):\n    \"\"\"JavaScript could not be executed.\"\"\"\n</code></pre>"},{"location":"api/#py_mini_racer.JSFunction","title":"<code>JSFunction</code>","text":"<p>               Bases: <code>JSMappedObject</code></p> <p>JavaScript function.</p> <p>This type is returned by synchronous MiniRacer contexts.</p> <p>You can call this object from Python, passing in positional args to match what the JavaScript function expects.</p> <p>In synchronous code you may supply an additional keyword argument, <code>timeout_sec</code>.</p> <p>If you are running in an async context in the same event loop as Miniracer, you must not supply a non-None value for timeout_sec. Instead call func.cancelable() to obtain a CancellableJSFunction, and use a construct like asyncio.wait_for(...) to apply a timeout.</p> Source code in <code>src/py_mini_racer/_types.py</code> <pre><code>class JSFunction(JSMappedObject):\n    \"\"\"JavaScript function.\n\n    This type is returned by synchronous MiniRacer contexts.\n\n    You can call this object from Python, passing in positional args to match what the\n    JavaScript function expects.\n\n    In synchronous code you may supply an additional keyword argument, `timeout_sec`.\n\n    If you are running in an async context in the same event loop as Miniracer, you must\n    not supply a non-None value for timeout_sec. Instead call func.cancelable() to\n    obtain a CancellableJSFunction, and use a construct like asyncio.wait_for(...) to\n    apply a timeout.\n    \"\"\"\n\n    def __call__(\n        self,\n        *args: PythonJSConvertedTypes,\n        this: JSObject | JSUndefinedType = JSUndefined,\n        timeout_sec: float | None = None,\n    ) -&gt; PythonJSConvertedTypes:\n        raise NotImplementedError\n\n    def cancelable(self) -&gt; CancelableJSFunction:\n        raise NotImplementedError\n</code></pre>"},{"location":"api/#py_mini_racer.JSKeyError","title":"<code>JSKeyError</code>","text":"<p>               Bases: <code>JSEvalException</code>, <code>KeyError</code></p> <p>No such key found.</p> Source code in <code>src/py_mini_racer/_exc.py</code> <pre><code>class JSKeyError(JSEvalException, KeyError):\n    \"\"\"No such key found.\"\"\"\n</code></pre>"},{"location":"api/#py_mini_racer.JSMappedObject","title":"<code>JSMappedObject</code>","text":"<p>               Bases: <code>MutableMapping['PythonJSConvertedTypes', 'PythonJSConvertedTypes']</code>, <code>JSObject</code></p> <p>A JavaScript object with Pythonic MutableMapping methods (<code>keys()</code>, <code>__getitem__()</code>, etc).</p> <p><code>keys()</code> and <code>__iter__()</code> will return properties from any prototypes as well as this object, as if using a for-in statement in JavaScript.</p> Source code in <code>src/py_mini_racer/_types.py</code> <pre><code>class JSMappedObject(\n    MutableMapping[\"PythonJSConvertedTypes\", \"PythonJSConvertedTypes\"], JSObject\n):\n    \"\"\"A JavaScript object with Pythonic MutableMapping methods (`keys()`,\n    `__getitem__()`, etc).\n\n    `keys()` and `__iter__()` will return properties from any prototypes as well as this\n    object, as if using a for-in statement in JavaScript.\n    \"\"\"\n</code></pre>"},{"location":"api/#py_mini_racer.JSOOMException","title":"<code>JSOOMException</code>","text":"<p>               Bases: <code>JSEvalException</code></p> <p>JavaScript execution ran out of memory.</p> Source code in <code>src/py_mini_racer/_exc.py</code> <pre><code>class JSOOMException(JSEvalException):\n    \"\"\"JavaScript execution ran out of memory.\"\"\"\n</code></pre>"},{"location":"api/#py_mini_racer.JSObject","title":"<code>JSObject</code>","text":"<p>A JavaScript object.</p> Source code in <code>src/py_mini_racer/_types.py</code> <pre><code>class JSObject:\n    \"\"\"A JavaScript object.\"\"\"\n</code></pre>"},{"location":"api/#py_mini_racer.JSParseException","title":"<code>JSParseException</code>","text":"<p>               Bases: <code>JSEvalException</code></p> <p>JavaScript could not be parsed.</p> Source code in <code>src/py_mini_racer/_exc.py</code> <pre><code>class JSParseException(JSEvalException):\n    \"\"\"JavaScript could not be parsed.\"\"\"\n</code></pre>"},{"location":"api/#py_mini_racer.JSPromise","title":"<code>JSPromise</code>","text":"<p>               Bases: <code>JSObject</code></p> <p>JavaScript Promise.</p> <p>To get a value, call <code>promise.get()</code> (which blocks) or <code>await promise</code> (in async code). Both operations will raise a Python exception if the JavaScript Promise is rejected.</p> Source code in <code>src/py_mini_racer/_types.py</code> <pre><code>class JSPromise(JSObject):\n    \"\"\"JavaScript Promise.\n\n    To get a value, call `promise.get()` (which blocks) or `await promise` (in async\n    code). Both operations will raise a Python exception if the JavaScript Promise is\n    rejected.\n    \"\"\"\n\n    def get(self, *, timeout: float | None = None) -&gt; PythonJSConvertedTypes:\n        raise NotImplementedError\n\n    def __await__(self) -&gt; Generator[Any, None, Any]:\n        raise NotImplementedError\n</code></pre>"},{"location":"api/#py_mini_racer.JSPromiseError","title":"<code>JSPromiseError</code>","text":"<p>               Bases: <code>MiniRacerBaseException</code></p> <p>JavaScript rejected a promise.</p> Source code in <code>src/py_mini_racer/_exc.py</code> <pre><code>class JSPromiseError(MiniRacerBaseException):\n    \"\"\"JavaScript rejected a promise.\"\"\"\n\n    def __init__(self, reason: PythonJSConvertedTypes) -&gt; None:\n        super().__init__(f\"JavaScript rejected promise with reason: {reason}\\n\")\n        self.reason = reason\n</code></pre>"},{"location":"api/#py_mini_racer.JSSymbol","title":"<code>JSSymbol</code>","text":"<p>               Bases: <code>JSMappedObject</code></p> <p>JavaScript symbol.</p> Source code in <code>src/py_mini_racer/_types.py</code> <pre><code>class JSSymbol(JSMappedObject):\n    \"\"\"JavaScript symbol.\"\"\"\n</code></pre>"},{"location":"api/#py_mini_racer.JSTimeoutException","title":"<code>JSTimeoutException</code>","text":"<p>               Bases: <code>JSEvalException</code>, <code>TimeoutError</code></p> <p>JavaScript execution timed out.</p> Source code in <code>src/py_mini_racer/_exc.py</code> <pre><code>class JSTimeoutException(JSEvalException, TimeoutError):  # noqa: N818\n    \"\"\"JavaScript execution timed out.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(\"JavaScript was terminated by timeout\")\n</code></pre>"},{"location":"api/#py_mini_racer.JSUndefinedType","title":"<code>JSUndefinedType</code>","text":"<p>The JavaScript undefined type.</p> <p>Where JavaScript null is represented as None, undefined is represented as this type.</p> Source code in <code>src/py_mini_racer/_types.py</code> <pre><code>class JSUndefinedType:\n    \"\"\"The JavaScript undefined type.\n\n    Where JavaScript null is represented as None, undefined is represented as this\n    type.\"\"\"\n\n    def __bool__(self) -&gt; bool:\n        return False\n\n    def __repr__(self) -&gt; str:\n        return \"JSUndefined\"\n</code></pre>"},{"location":"api/#py_mini_racer.JSValueError","title":"<code>JSValueError</code>","text":"<p>               Bases: <code>JSEvalException</code>, <code>ValueError</code></p> <p>Bad value passed to JavaScript engine.</p> Source code in <code>src/py_mini_racer/_exc.py</code> <pre><code>class JSValueError(JSEvalException, ValueError):\n    \"\"\"Bad value passed to JavaScript engine.\"\"\"\n</code></pre>"},{"location":"api/#py_mini_racer.LibAlreadyInitializedError","title":"<code>LibAlreadyInitializedError</code>","text":"<p>               Bases: <code>MiniRacerBaseException</code></p> <p>MiniRacer-wrapped V8 build not found.</p> Source code in <code>src/py_mini_racer/_dll.py</code> <pre><code>class LibAlreadyInitializedError(MiniRacerBaseException):\n    \"\"\"MiniRacer-wrapped V8 build not found.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(\n            \"MiniRacer was already initialized before the call to init_mini_racer\"\n        )\n</code></pre>"},{"location":"api/#py_mini_racer.LibNotFoundError","title":"<code>LibNotFoundError</code>","text":"<p>               Bases: <code>MiniRacerBaseException</code></p> <p>MiniRacer-wrapped V8 build not found.</p> Source code in <code>src/py_mini_racer/_dll.py</code> <pre><code>class LibNotFoundError(MiniRacerBaseException):\n    \"\"\"MiniRacer-wrapped V8 build not found.\"\"\"\n\n    def __init__(self, path: Path) -&gt; None:\n        super().__init__(f\"Native library or dependency not available at {path}\")\n</code></pre>"},{"location":"api/#py_mini_racer.MiniRacer","title":"<code>MiniRacer</code>","text":"<p>MiniRacer evaluates JavaScript code using a V8 isolate.</p> <p>A MiniRacer instance can be explicitly closed using the close() method, or by using the MiniRacer as a context manager, i.e,:</p> <p>with MiniRacer() as mr:     ...</p> <p>The MiniRacer instance will otherwise clean up the underlying V8 resources upon garbage collection.</p> <p>Attributes:</p> Name Type Description <code>json_impl</code> <code>Any</code> <p>JSON module used by helper methods default is json</p> Source code in <code>src/py_mini_racer/_mini_racer.py</code> <pre><code>class MiniRacer:\n    \"\"\"\n    MiniRacer evaluates JavaScript code using a V8 isolate.\n\n    A MiniRacer instance can be explicitly closed using the close() method, or by using\n    the MiniRacer as a context manager, i.e,:\n\n    with MiniRacer() as mr:\n        ...\n\n    The MiniRacer instance will otherwise clean up the underlying V8 resources upon\n    garbage collection.\n\n    Attributes:\n        json_impl: JSON module used by helper methods default is\n            [json](https://docs.python.org/3/library/json.html)\n    \"\"\"\n\n    json_impl: ClassVar[Any] = json\n\n    def __init__(self, context: Context | None = None) -&gt; None:\n        if context is None:\n            self._own_context_maker: AbstractContextManager[Context] | None = (\n                _make_context()\n            )\n            self._ctx: Context | None = self._own_context_maker.__enter__()\n        else:\n            self._own_context_maker = None\n            self._ctx = context\n\n        self.eval(INSTALL_SET_TIMEOUT)\n\n    def close(\n        self,\n        exc_type: type[BaseException] | None = None,\n        exc_val: BaseException | None = None,\n        exc_tb: TracebackType | None = None,\n    ) -&gt; None:\n        \"\"\"Close this MiniRacer instance.\n\n        It is an error to use this MiniRacer instance or any JS objects returned by it\n        after calling this method.\n        \"\"\"\n        own_context_maker = self._own_context_maker\n        self._own_context_maker = None\n        self._ctx = None\n\n        if own_context_maker is not None:\n            own_context_maker.__exit__(exc_type, exc_val, exc_tb)\n\n    def __del__(self) -&gt; None:\n        # Ignore ordering problems on process teardown.\n        # (A user who wants consistent teardown should use `with MiniRacer() as ctx`\n        # which makes the cleanup deterministic.)\n        with suppress(Exception):\n            self.close()\n\n    def __enter__(self) -&gt; Self:\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; None:\n        self.close(exc_type, exc_val, exc_tb)\n\n    @property\n    def v8_version(self) -&gt; str:\n        \"\"\"Return the V8 version string.\"\"\"\n        assert self._ctx is not None\n        return self._ctx.v8_version()\n\n    def eval(\n        self,\n        code: str,\n        timeout: float | None = None,\n        timeout_sec: float | None = None,\n        max_memory: int | None = None,\n    ) -&gt; PythonJSConvertedTypes:\n        \"\"\"Evaluate JavaScript code in the V8 isolate.\n\n        Side effects from the JavaScript evaluation is persisted inside a context\n        (meaning variables set are kept for the next evaluation).\n\n        The JavaScript value returned by the last expression in `code` is converted to\n        a Python value and returned by this method. Only primitive types are supported\n        (numbers, strings, buffers...). Use the\n        [py_mini_racer.MiniRacer.execute][] method to return more complex\n        types such as arrays or objects.\n\n        The evaluation can be interrupted by an exception for several reasons: a limit\n        was reached, the code could not be parsed, a returned value could not be\n        converted to a Python value.\n\n        Args:\n            code: JavaScript code\n            timeout: number of milliseconds after which the execution is interrupted.\n                This is deprecated; use timeout_sec instead.\n            timeout_sec: number of seconds after which the execution is interrupted\n            max_memory: hard memory limit, in bytes, after which the execution is\n                interrupted.\n        \"\"\"\n\n        if max_memory is not None:\n            self.set_hard_memory_limit(max_memory)\n\n        if timeout:\n            # PyMiniRacer unfortunately uses milliseconds while Python and\n            # Syst\u00e8me international d'unit\u00e9s use seconds.\n            timeout_sec = timeout / 1000\n\n        ctx = self._ctx\n        assert ctx is not None\n\n        if not ctx.are_we_running_on_the_mini_racer_event_loop():\n\n            async def run() -&gt; PythonJSConvertedTypes:\n                try:\n                    return await asyncio.wait_for(\n                        ctx.eval_cancelable(code), timeout=timeout_sec\n                    )\n                except asyncio.TimeoutError as e:\n                    raise JSTimeoutException from e\n\n            return asyncio.run_coroutine_threadsafe(run(), ctx.event_loop).result()\n\n        assert timeout_sec is None, (\n            \"To apply a timeout in an async context, use \"\n            \"`await asyncio.wait_for(mr.eval_cancelable(your_params), \"\n            \"timeout=your_timeout)`\"\n        )\n\n        return ctx.eval(code)\n\n    async def eval_cancelable(self, code: str) -&gt; PythonJSConvertedTypes:\n        \"\"\"Evaluate JavaScript code in the V8 isolate.\n\n        Similar to eval(), but runaway calls can be canceled by canceling the\n        coroutine's task, e.g., using:\n\n            await asyncio.wait_for(mr.eval_cancelable(...), timeout=some_timeout)\n\n        \"\"\"\n\n        assert self._ctx is not None\n\n        return await self._ctx.eval_cancelable(code)\n\n    def execute(\n        self,\n        expr: str,\n        timeout: float | None = None,\n        timeout_sec: float | None = None,\n        max_memory: int | None = None,\n    ) -&gt; Any:  # noqa: ANN401\n        \"\"\"Helper to evaluate a JavaScript expression and return composite types.\n\n        Returned value is serialized to JSON inside the V8 isolate and deserialized\n        using `json_impl`.\n\n        Args:\n            expr: JavaScript expression\n            timeout: number of milliseconds after which the execution is interrupted.\n                This is deprecated; use timeout_sec instead.\n            timeout_sec: number of seconds after which the execution is interrupted\n            max_memory: hard memory limit, in bytes, after which the execution is\n                interrupted.\n        \"\"\"\n\n        if timeout:\n            # PyMiniRacer unfortunately uses milliseconds while Python and\n            # Syst\u00e8me international d'unit\u00e9s use seconds.\n            timeout_sec = timeout / 1000\n\n        wrapped_expr = f\"JSON.stringify((function(){{return ({expr})}})())\"\n        ret = self.eval(wrapped_expr, timeout_sec=timeout_sec, max_memory=max_memory)\n        if not isinstance(ret, str):\n            raise WrongReturnTypeException(type(ret))\n        return self.json_impl.loads(ret)\n\n    def call(\n        self,\n        expr: str,\n        *args: Any,  # noqa: ANN401\n        encoder: type[JSONEncoder] | None = None,\n        timeout: float | None = None,\n        timeout_sec: float | None = None,\n        max_memory: int | None = None,\n    ) -&gt; Any:  # noqa: ANN401\n        \"\"\"Helper to call a JavaScript function and return compositve types.\n\n        The `expr` argument refers to a JavaScript function in the current V8\n        isolate context. Further positional arguments are serialized using the JSON\n        implementation `json_impl` and passed to the JavaScript function as arguments.\n\n        Returned value is serialized to JSON inside the V8 isolate and deserialized\n        using `json_impl`.\n\n        Args:\n            expr: JavaScript expression referring to a function\n            encoder: Custom JSON encoder\n            timeout: number of milliseconds after which the execution is\n                interrupted.\n            timeout_sec: number of seconds after which the execution is interrupted\n            max_memory: hard memory limit, in bytes, after which the execution is\n                interrupted\n        \"\"\"\n\n        if timeout:\n            # PyMiniRacer unfortunately uses milliseconds while Python and\n            # Syst\u00e8me international d'unit\u00e9s use seconds.\n            timeout_sec = timeout / 1000\n\n        json_args = self.json_impl.dumps(args, separators=(\",\", \":\"), cls=encoder)\n        js = f\"{expr}.apply(this, {json_args})\"\n        return self.execute(js, timeout_sec=timeout_sec, max_memory=max_memory)\n\n    @asynccontextmanager\n    async def wrap_py_function(\n        self, func: PyJsFunctionType\n    ) -&gt; AsyncGenerator[JSFunction, None]:\n        \"\"\"Wrap a Python function such that it can be called from JS.\n\n        To be wrapped and exposed in JavaScript, a Python function should:\n\n          1. Be async,\n          2. Accept variable positional arguments each of type PythonJSConvertedTypes,\n             and\n          3. Return one value of type PythonJSConvertedTypes (a type union which\n             includes None).\n\n        The function is rendered on the JavaScript side as an async function (i.e., a\n        function which returns a Promise).\n\n        Returns:\n            An async context manager which, when entered, yields a JS Function which\n            can be passed into MiniRacer and called by JS code.\n        \"\"\"\n\n        assert self._ctx is not None\n\n        async with self._ctx.wrap_py_function_as_js_function(func) as js_func:\n            yield js_func\n\n    def set_hard_memory_limit(self, limit: int) -&gt; None:\n        \"\"\"Set a hard memory limit on this V8 isolate.\n\n        JavaScript execution will be terminated when this limit is reached.\n\n        :param int limit: memory limit in bytes or 0 to reset the limit\n        \"\"\"\n\n        assert self._ctx is not None\n        self._ctx.set_hard_memory_limit(limit)\n\n    def set_soft_memory_limit(self, limit: int) -&gt; None:\n        \"\"\"Set a soft memory limit on this V8 isolate.\n\n        The Garbage Collection will use a more aggressive strategy when\n        the soft limit is reached but the execution will not be stopped.\n\n        :param int limit: memory limit in bytes or 0 to reset the limit\n        \"\"\"\n\n        assert self._ctx is not None\n        self._ctx.set_soft_memory_limit(limit)\n\n    def was_hard_memory_limit_reached(self) -&gt; bool:\n        \"\"\"Return true if the hard memory limit was reached on the V8 isolate.\"\"\"\n\n        assert self._ctx is not None\n        return self._ctx.was_hard_memory_limit_reached()\n\n    def was_soft_memory_limit_reached(self) -&gt; bool:\n        \"\"\"Return true if the soft memory limit was reached on the V8 isolate.\"\"\"\n\n        assert self._ctx is not None\n        return self._ctx.was_soft_memory_limit_reached()\n\n    def low_memory_notification(self) -&gt; None:\n        \"\"\"Ask the V8 isolate to collect memory more aggressively.\"\"\"\n\n        assert self._ctx is not None\n        self._ctx.low_memory_notification()\n\n    def heap_stats(self) -&gt; Any:  # noqa: ANN401\n        \"\"\"Return the V8 isolate heap statistics.\"\"\"\n\n        assert self._ctx is not None\n        return self.json_impl.loads(self._ctx.heap_stats())\n\n    def heap_snapshot(self) -&gt; Any:  # noqa: ANN401\n        \"\"\"Return a snapshot of the V8 isolate heap.\"\"\"\n\n        assert self._ctx is not None\n        return self.json_impl.loads(self._ctx.heap_snapshot())\n</code></pre>"},{"location":"api/#py_mini_racer.MiniRacer.v8_version","title":"<code>v8_version</code>  <code>property</code>","text":"<p>Return the V8 version string.</p>"},{"location":"api/#py_mini_racer.MiniRacer.call","title":"<code>call(expr, *args, encoder=None, timeout=None, timeout_sec=None, max_memory=None)</code>","text":"<p>Helper to call a JavaScript function and return compositve types.</p> <p>The <code>expr</code> argument refers to a JavaScript function in the current V8 isolate context. Further positional arguments are serialized using the JSON implementation <code>json_impl</code> and passed to the JavaScript function as arguments.</p> <p>Returned value is serialized to JSON inside the V8 isolate and deserialized using <code>json_impl</code>.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>str</code> <p>JavaScript expression referring to a function</p> required <code>encoder</code> <code>type[JSONEncoder] | None</code> <p>Custom JSON encoder</p> <code>None</code> <code>timeout</code> <code>float | None</code> <p>number of milliseconds after which the execution is interrupted.</p> <code>None</code> <code>timeout_sec</code> <code>float | None</code> <p>number of seconds after which the execution is interrupted</p> <code>None</code> <code>max_memory</code> <code>int | None</code> <p>hard memory limit, in bytes, after which the execution is interrupted</p> <code>None</code> Source code in <code>src/py_mini_racer/_mini_racer.py</code> <pre><code>def call(\n    self,\n    expr: str,\n    *args: Any,  # noqa: ANN401\n    encoder: type[JSONEncoder] | None = None,\n    timeout: float | None = None,\n    timeout_sec: float | None = None,\n    max_memory: int | None = None,\n) -&gt; Any:  # noqa: ANN401\n    \"\"\"Helper to call a JavaScript function and return compositve types.\n\n    The `expr` argument refers to a JavaScript function in the current V8\n    isolate context. Further positional arguments are serialized using the JSON\n    implementation `json_impl` and passed to the JavaScript function as arguments.\n\n    Returned value is serialized to JSON inside the V8 isolate and deserialized\n    using `json_impl`.\n\n    Args:\n        expr: JavaScript expression referring to a function\n        encoder: Custom JSON encoder\n        timeout: number of milliseconds after which the execution is\n            interrupted.\n        timeout_sec: number of seconds after which the execution is interrupted\n        max_memory: hard memory limit, in bytes, after which the execution is\n            interrupted\n    \"\"\"\n\n    if timeout:\n        # PyMiniRacer unfortunately uses milliseconds while Python and\n        # Syst\u00e8me international d'unit\u00e9s use seconds.\n        timeout_sec = timeout / 1000\n\n    json_args = self.json_impl.dumps(args, separators=(\",\", \":\"), cls=encoder)\n    js = f\"{expr}.apply(this, {json_args})\"\n    return self.execute(js, timeout_sec=timeout_sec, max_memory=max_memory)\n</code></pre>"},{"location":"api/#py_mini_racer.MiniRacer.close","title":"<code>close(exc_type=None, exc_val=None, exc_tb=None)</code>","text":"<p>Close this MiniRacer instance.</p> <p>It is an error to use this MiniRacer instance or any JS objects returned by it after calling this method.</p> Source code in <code>src/py_mini_racer/_mini_racer.py</code> <pre><code>def close(\n    self,\n    exc_type: type[BaseException] | None = None,\n    exc_val: BaseException | None = None,\n    exc_tb: TracebackType | None = None,\n) -&gt; None:\n    \"\"\"Close this MiniRacer instance.\n\n    It is an error to use this MiniRacer instance or any JS objects returned by it\n    after calling this method.\n    \"\"\"\n    own_context_maker = self._own_context_maker\n    self._own_context_maker = None\n    self._ctx = None\n\n    if own_context_maker is not None:\n        own_context_maker.__exit__(exc_type, exc_val, exc_tb)\n</code></pre>"},{"location":"api/#py_mini_racer.MiniRacer.eval","title":"<code>eval(code, timeout=None, timeout_sec=None, max_memory=None)</code>","text":"<p>Evaluate JavaScript code in the V8 isolate.</p> <p>Side effects from the JavaScript evaluation is persisted inside a context (meaning variables set are kept for the next evaluation).</p> <p>The JavaScript value returned by the last expression in <code>code</code> is converted to a Python value and returned by this method. Only primitive types are supported (numbers, strings, buffers...). Use the py_mini_racer.MiniRacer.execute method to return more complex types such as arrays or objects.</p> <p>The evaluation can be interrupted by an exception for several reasons: a limit was reached, the code could not be parsed, a returned value could not be converted to a Python value.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>JavaScript code</p> required <code>timeout</code> <code>float | None</code> <p>number of milliseconds after which the execution is interrupted. This is deprecated; use timeout_sec instead.</p> <code>None</code> <code>timeout_sec</code> <code>float | None</code> <p>number of seconds after which the execution is interrupted</p> <code>None</code> <code>max_memory</code> <code>int | None</code> <p>hard memory limit, in bytes, after which the execution is interrupted.</p> <code>None</code> Source code in <code>src/py_mini_racer/_mini_racer.py</code> <pre><code>def eval(\n    self,\n    code: str,\n    timeout: float | None = None,\n    timeout_sec: float | None = None,\n    max_memory: int | None = None,\n) -&gt; PythonJSConvertedTypes:\n    \"\"\"Evaluate JavaScript code in the V8 isolate.\n\n    Side effects from the JavaScript evaluation is persisted inside a context\n    (meaning variables set are kept for the next evaluation).\n\n    The JavaScript value returned by the last expression in `code` is converted to\n    a Python value and returned by this method. Only primitive types are supported\n    (numbers, strings, buffers...). Use the\n    [py_mini_racer.MiniRacer.execute][] method to return more complex\n    types such as arrays or objects.\n\n    The evaluation can be interrupted by an exception for several reasons: a limit\n    was reached, the code could not be parsed, a returned value could not be\n    converted to a Python value.\n\n    Args:\n        code: JavaScript code\n        timeout: number of milliseconds after which the execution is interrupted.\n            This is deprecated; use timeout_sec instead.\n        timeout_sec: number of seconds after which the execution is interrupted\n        max_memory: hard memory limit, in bytes, after which the execution is\n            interrupted.\n    \"\"\"\n\n    if max_memory is not None:\n        self.set_hard_memory_limit(max_memory)\n\n    if timeout:\n        # PyMiniRacer unfortunately uses milliseconds while Python and\n        # Syst\u00e8me international d'unit\u00e9s use seconds.\n        timeout_sec = timeout / 1000\n\n    ctx = self._ctx\n    assert ctx is not None\n\n    if not ctx.are_we_running_on_the_mini_racer_event_loop():\n\n        async def run() -&gt; PythonJSConvertedTypes:\n            try:\n                return await asyncio.wait_for(\n                    ctx.eval_cancelable(code), timeout=timeout_sec\n                )\n            except asyncio.TimeoutError as e:\n                raise JSTimeoutException from e\n\n        return asyncio.run_coroutine_threadsafe(run(), ctx.event_loop).result()\n\n    assert timeout_sec is None, (\n        \"To apply a timeout in an async context, use \"\n        \"`await asyncio.wait_for(mr.eval_cancelable(your_params), \"\n        \"timeout=your_timeout)`\"\n    )\n\n    return ctx.eval(code)\n</code></pre>"},{"location":"api/#py_mini_racer.MiniRacer.eval_cancelable","title":"<code>eval_cancelable(code)</code>  <code>async</code>","text":"<p>Evaluate JavaScript code in the V8 isolate.</p> <p>Similar to eval(), but runaway calls can be canceled by canceling the coroutine's task, e.g., using:</p> <pre><code>await asyncio.wait_for(mr.eval_cancelable(...), timeout=some_timeout)\n</code></pre> Source code in <code>src/py_mini_racer/_mini_racer.py</code> <pre><code>async def eval_cancelable(self, code: str) -&gt; PythonJSConvertedTypes:\n    \"\"\"Evaluate JavaScript code in the V8 isolate.\n\n    Similar to eval(), but runaway calls can be canceled by canceling the\n    coroutine's task, e.g., using:\n\n        await asyncio.wait_for(mr.eval_cancelable(...), timeout=some_timeout)\n\n    \"\"\"\n\n    assert self._ctx is not None\n\n    return await self._ctx.eval_cancelable(code)\n</code></pre>"},{"location":"api/#py_mini_racer.MiniRacer.execute","title":"<code>execute(expr, timeout=None, timeout_sec=None, max_memory=None)</code>","text":"<p>Helper to evaluate a JavaScript expression and return composite types.</p> <p>Returned value is serialized to JSON inside the V8 isolate and deserialized using <code>json_impl</code>.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>str</code> <p>JavaScript expression</p> required <code>timeout</code> <code>float | None</code> <p>number of milliseconds after which the execution is interrupted. This is deprecated; use timeout_sec instead.</p> <code>None</code> <code>timeout_sec</code> <code>float | None</code> <p>number of seconds after which the execution is interrupted</p> <code>None</code> <code>max_memory</code> <code>int | None</code> <p>hard memory limit, in bytes, after which the execution is interrupted.</p> <code>None</code> Source code in <code>src/py_mini_racer/_mini_racer.py</code> <pre><code>def execute(\n    self,\n    expr: str,\n    timeout: float | None = None,\n    timeout_sec: float | None = None,\n    max_memory: int | None = None,\n) -&gt; Any:  # noqa: ANN401\n    \"\"\"Helper to evaluate a JavaScript expression and return composite types.\n\n    Returned value is serialized to JSON inside the V8 isolate and deserialized\n    using `json_impl`.\n\n    Args:\n        expr: JavaScript expression\n        timeout: number of milliseconds after which the execution is interrupted.\n            This is deprecated; use timeout_sec instead.\n        timeout_sec: number of seconds after which the execution is interrupted\n        max_memory: hard memory limit, in bytes, after which the execution is\n            interrupted.\n    \"\"\"\n\n    if timeout:\n        # PyMiniRacer unfortunately uses milliseconds while Python and\n        # Syst\u00e8me international d'unit\u00e9s use seconds.\n        timeout_sec = timeout / 1000\n\n    wrapped_expr = f\"JSON.stringify((function(){{return ({expr})}})())\"\n    ret = self.eval(wrapped_expr, timeout_sec=timeout_sec, max_memory=max_memory)\n    if not isinstance(ret, str):\n        raise WrongReturnTypeException(type(ret))\n    return self.json_impl.loads(ret)\n</code></pre>"},{"location":"api/#py_mini_racer.MiniRacer.heap_snapshot","title":"<code>heap_snapshot()</code>","text":"<p>Return a snapshot of the V8 isolate heap.</p> Source code in <code>src/py_mini_racer/_mini_racer.py</code> <pre><code>def heap_snapshot(self) -&gt; Any:  # noqa: ANN401\n    \"\"\"Return a snapshot of the V8 isolate heap.\"\"\"\n\n    assert self._ctx is not None\n    return self.json_impl.loads(self._ctx.heap_snapshot())\n</code></pre>"},{"location":"api/#py_mini_racer.MiniRacer.heap_stats","title":"<code>heap_stats()</code>","text":"<p>Return the V8 isolate heap statistics.</p> Source code in <code>src/py_mini_racer/_mini_racer.py</code> <pre><code>def heap_stats(self) -&gt; Any:  # noqa: ANN401\n    \"\"\"Return the V8 isolate heap statistics.\"\"\"\n\n    assert self._ctx is not None\n    return self.json_impl.loads(self._ctx.heap_stats())\n</code></pre>"},{"location":"api/#py_mini_racer.MiniRacer.low_memory_notification","title":"<code>low_memory_notification()</code>","text":"<p>Ask the V8 isolate to collect memory more aggressively.</p> Source code in <code>src/py_mini_racer/_mini_racer.py</code> <pre><code>def low_memory_notification(self) -&gt; None:\n    \"\"\"Ask the V8 isolate to collect memory more aggressively.\"\"\"\n\n    assert self._ctx is not None\n    self._ctx.low_memory_notification()\n</code></pre>"},{"location":"api/#py_mini_racer.MiniRacer.set_hard_memory_limit","title":"<code>set_hard_memory_limit(limit)</code>","text":"<p>Set a hard memory limit on this V8 isolate.</p> <p>JavaScript execution will be terminated when this limit is reached.</p> <p>:param int limit: memory limit in bytes or 0 to reset the limit</p> Source code in <code>src/py_mini_racer/_mini_racer.py</code> <pre><code>def set_hard_memory_limit(self, limit: int) -&gt; None:\n    \"\"\"Set a hard memory limit on this V8 isolate.\n\n    JavaScript execution will be terminated when this limit is reached.\n\n    :param int limit: memory limit in bytes or 0 to reset the limit\n    \"\"\"\n\n    assert self._ctx is not None\n    self._ctx.set_hard_memory_limit(limit)\n</code></pre>"},{"location":"api/#py_mini_racer.MiniRacer.set_soft_memory_limit","title":"<code>set_soft_memory_limit(limit)</code>","text":"<p>Set a soft memory limit on this V8 isolate.</p> <p>The Garbage Collection will use a more aggressive strategy when the soft limit is reached but the execution will not be stopped.</p> <p>:param int limit: memory limit in bytes or 0 to reset the limit</p> Source code in <code>src/py_mini_racer/_mini_racer.py</code> <pre><code>def set_soft_memory_limit(self, limit: int) -&gt; None:\n    \"\"\"Set a soft memory limit on this V8 isolate.\n\n    The Garbage Collection will use a more aggressive strategy when\n    the soft limit is reached but the execution will not be stopped.\n\n    :param int limit: memory limit in bytes or 0 to reset the limit\n    \"\"\"\n\n    assert self._ctx is not None\n    self._ctx.set_soft_memory_limit(limit)\n</code></pre>"},{"location":"api/#py_mini_racer.MiniRacer.was_hard_memory_limit_reached","title":"<code>was_hard_memory_limit_reached()</code>","text":"<p>Return true if the hard memory limit was reached on the V8 isolate.</p> Source code in <code>src/py_mini_racer/_mini_racer.py</code> <pre><code>def was_hard_memory_limit_reached(self) -&gt; bool:\n    \"\"\"Return true if the hard memory limit was reached on the V8 isolate.\"\"\"\n\n    assert self._ctx is not None\n    return self._ctx.was_hard_memory_limit_reached()\n</code></pre>"},{"location":"api/#py_mini_racer.MiniRacer.was_soft_memory_limit_reached","title":"<code>was_soft_memory_limit_reached()</code>","text":"<p>Return true if the soft memory limit was reached on the V8 isolate.</p> Source code in <code>src/py_mini_racer/_mini_racer.py</code> <pre><code>def was_soft_memory_limit_reached(self) -&gt; bool:\n    \"\"\"Return true if the soft memory limit was reached on the V8 isolate.\"\"\"\n\n    assert self._ctx is not None\n    return self._ctx.was_soft_memory_limit_reached()\n</code></pre>"},{"location":"api/#py_mini_racer.MiniRacer.wrap_py_function","title":"<code>wrap_py_function(func)</code>  <code>async</code>","text":"<p>Wrap a Python function such that it can be called from JS.</p> <p>To be wrapped and exposed in JavaScript, a Python function should:</p> <ol> <li>Be async,</li> <li>Accept variable positional arguments each of type PythonJSConvertedTypes,      and</li> <li>Return one value of type PythonJSConvertedTypes (a type union which      includes None).</li> </ol> <p>The function is rendered on the JavaScript side as an async function (i.e., a function which returns a Promise).</p> <p>Returns:</p> Type Description <code>AsyncGenerator[JSFunction, None]</code> <p>An async context manager which, when entered, yields a JS Function which</p> <code>AsyncGenerator[JSFunction, None]</code> <p>can be passed into MiniRacer and called by JS code.</p> Source code in <code>src/py_mini_racer/_mini_racer.py</code> <pre><code>@asynccontextmanager\nasync def wrap_py_function(\n    self, func: PyJsFunctionType\n) -&gt; AsyncGenerator[JSFunction, None]:\n    \"\"\"Wrap a Python function such that it can be called from JS.\n\n    To be wrapped and exposed in JavaScript, a Python function should:\n\n      1. Be async,\n      2. Accept variable positional arguments each of type PythonJSConvertedTypes,\n         and\n      3. Return one value of type PythonJSConvertedTypes (a type union which\n         includes None).\n\n    The function is rendered on the JavaScript side as an async function (i.e., a\n    function which returns a Promise).\n\n    Returns:\n        An async context manager which, when entered, yields a JS Function which\n        can be passed into MiniRacer and called by JS code.\n    \"\"\"\n\n    assert self._ctx is not None\n\n    async with self._ctx.wrap_py_function_as_js_function(func) as js_func:\n        yield js_func\n</code></pre>"},{"location":"api/#py_mini_racer.init_mini_racer","title":"<code>init_mini_racer(*, flags=DEFAULT_V8_FLAGS, ignore_duplicate_init=False)</code>","text":"<p>Initialize py_mini_racer (and V8).</p> <p>This function can optionally be used to set V8 flags. This function can be called at most once, before any instances of MiniRacer are initialized. Instances of MiniRacer will automatically call this function to initialize MiniRacer and V8.</p> Source code in <code>src/py_mini_racer/_dll.py</code> <pre><code>def init_mini_racer(\n    *, flags: Iterable[str] = DEFAULT_V8_FLAGS, ignore_duplicate_init: bool = False\n) -&gt; ctypes.CDLL:\n    \"\"\"Initialize py_mini_racer (and V8).\n\n    This function can optionally be used to set V8 flags. This function can be called\n    at most once, before any instances of MiniRacer are initialized. Instances of\n    MiniRacer will automatically call this function to initialize MiniRacer and V8.\n    \"\"\"\n\n    global _dll_handle_context_manager  # noqa: PLW0603\n    global _dll_handle  # noqa: PLW0603\n\n    with _init_lock:\n        if _dll_handle is None:\n            _dll_handle_context_manager = _open_dll(flags)\n            _dll_handle = _dll_handle_context_manager.__enter__()\n            # Note: we never call _dll_handle_context_manager.__exit__() because it's\n            # designed as a singleton. But we could if we wanted to!\n        elif not ignore_duplicate_init:\n            raise LibAlreadyInitializedError\n\n        return _dll_handle\n</code></pre>"},{"location":"architecture/","title":"Architecture","text":"<p>This document contains some notes about the design of PyMiniRacer.</p>"},{"location":"architecture/#security-goals","title":"Security goals","text":"<p>First and foremost, PyMiniRacer makes no guarantees or warrantees, as noted in the license. This section documents the security goals of PyMiniRacer. Anything that doesn't meet these goals should be considered to be a bug (but with no warrantee or even a guaranteed path to remediation).</p>"},{"location":"architecture/#pyminiracer-should-be-able-to-run-untrusted-javascript-code","title":"PyMiniRacer should be able to run untrusted JavaScript code","text":"<p>The ability for PyMiniRacer to run untrusted JavaScript code was an original design goal for Sqreen in developing PyMiniRacer, and continues to be a design goal today.</p> <p>To that end, PyMiniRacer provides:</p> <ol> <li> <p>The innate sandboxing properties of V8. V8 is trusted by billions of folks to run    untrusted JavaScript every day, as a part of Chrome and other web browsers. It has    many features like the security sandbox and undergoes    close security scrutiny.</p> </li> <li> <p>The ability to create multiple <code>MiniRacer</code> instances which each have separate V8    isolates, to separate different blobs of untrusted code from each other.</p> </li> <li> <p>Optional timeouts and memory constraints on code being executed.</p> </li> </ol> <p>Caveats:</p> <ol> <li> <p>The continual security research is V8 under yields a corresponding    stream of vulnerability reports.</p> </li> <li> <p>... and while V8 as embedded in a web browser will typically receive (funded!)    updates to correct those vulnerabilities, PyMiniRacer is unlikely to see as    aggressive and consistent an update schedule.</p> </li> <li> <p>... and of course PyMiniRacer itself may have vulnerabilities.    This has happened before.</p> </li> <li> <p>... and even if PyMiniRacer is updated to accomodate a vulnerability fix in itself or    V8, it is incumbent upon Python applications which integrate it to actually redeploy    with the new PyMiniRacer version.</p> </li> </ol> <p>If running potentially adversarial JavaScript code in a high-security environment, it might be a better choice to run code using a purpose-built isolation environment such as containers on gVisor, than to rely on PyMiniRacer for isolation.</p>"},{"location":"architecture/#javascript-to-python-callbacks-may-breach-any-isolation-boundary","title":"JavaScript-to-Python callbacks may breach any isolation boundary","text":"<p>The <code>MiniRacer.wrap_py_function</code> method allows PyMiniRacer users to expose Python functions they write to JavaScript. This creates an extension framework which essentially breaches the isolation boundary provided by V8.</p> <p>This feature should only be used if the underlying JavaScript code is trusted, or if the author is certain the exposed Python function is safe for calls from untrusted code. (I.e., if you expose a Python function which allows reading arbitrary files from disk, this would obviously be bad if the JavaScript code which may call it is itself untrusted.)</p>"},{"location":"architecture/#brief-catalog-of-key-components","title":"Brief catalog of key components","text":""},{"location":"architecture/#docs","title":"<code>docs/</code>","text":"<p>This is the <code>mkdocs</code>  site for PyMiniRacer. To maximize compatibility with standard open-source repository layout, this directory is just a bunch of stubs which include files from the package root.</p>"},{"location":"architecture/#justfile","title":"<code>Justfile</code>","text":"<p>This is the main control board for PyMiniRacer dev work, for manual operations and GitHub Actions alike.</p>"},{"location":"architecture/#setuppy","title":"<code>setup.py</code>","text":"<p>This is a custom distutils setup script, required to:</p> <ol> <li>Set a custom architecture tag for the wheel (indicating the build is arch-dependent    but not specific to a Python version), and</li> <li>Generate a readme!</li> </ol> <p>We leave the v8 build out of the Python setuptools system because it's slow and fragile and actually unrelated to Python, and thus ill-served by the wrapping provided by Python setuptools and uv.</p>"},{"location":"architecture/#builderv8_buildpy","title":"<code>builder/v8_build.py</code>","text":"<p>This is the PyMiniRacer V8 build wrapper. Building V8 for many platforms (Windows, Mac, glibc Linux, musl Linux) and architectures (x86_64, aarch64) is hard, especially since V8 is primarily intended to be built by Google engineers on a somewhat different set of of platforms (i.e., those Chrome runs on), and typically via cross-compiled from relatively curated build hosts. So this file is complicated and full of <code>if</code> statements.</p>"},{"location":"architecture/#srcv8_py_frontend","title":"<code>src/v8_py_frontend/</code>","text":"<p>This is a small frontend for V8, written in C++. It manages initialization, context, marshals and unmarshals inputs and outputs through V8's type system, etc. The front-end exposes simple functions and types which are friendly to the Python <code>ctypes</code> system. These simple C++ functions in turn call the C++ V8 APIs.</p> <p>As noted below, <code>v8_py_frontend</code> is not a Python extension (it does not include <code>Python.h</code> or link <code>libpython</code>, and it does not touch Python types).</p>"},{"location":"architecture/#compiled-srcpy_mini_racerlibmini_racerso-srcpy_mini_racermini_racerdll-srcpy_mini_racerlibmini_racerdylib","title":"(Compiled) <code>src/py_mini_racer/libmini_racer.so</code>, <code>src/py_mini_racer/mini_racer.dll</code>, <code>src/py_mini_racer/libmini_racer.dylib</code>","text":"<p>These files (which one depends on the platform) contain the compiled V8 build, complete with the frontend from <code>src/v8_py_frontend</code>.</p>"},{"location":"architecture/#compiled-srcpy_mini_racericudtldat","title":"(Compiled) <code>src/py_mini_racer/icudtl.dat</code>","text":"<p>This is a build-time-generated internationalization artifact, used at runtime by V8 and thus shipped with PyMiniRacer.</p>"},{"location":"architecture/#defunct-srcpy_mini_racersnapshot_blobbin","title":"(Defunct) <code>src/py_mini_racer/snapshot_blob.bin</code>","text":"<p>Update: We now build this into PyMiniRacer using a v8 \"monolith\" build.</p> <p>This ~is~ was a build-time-generated startup snapshot, used at runtime by V8 and thus shipped with PyMiniRacer. This is a snapshot of the JavaScript heap including JavaScript built-ins, which accelerates JS engine startup.</p>"},{"location":"architecture/#srcpy_mini_racer","title":"<code>src/py_mini_racer/</code>","text":"<p>This is the pure-Python implementation of PyMiniRacer. This loads the (Python-independent) PyMiniRacer dynamic-link library (<code>.dll</code> on windows, <code>.so</code> on Linux, <code>.dylib</code> on MacOS) and uses the Python <code>ctypes</code> system to call methods within it, to manage V8 context and actually evaluate JavaScript code.</p>"},{"location":"architecture/#githubworkflowsbuildyml","title":"<code>.github/workflows/build.yml</code>","text":"<p>This is the primary build script for PyMiniRacer, implemented as a GitHub Actions workflow.</p>"},{"location":"architecture/#design-decisions","title":"Design decisions","text":"<p>These are listed in a topological sort, from most-fundamental to most-derived decisions.</p> <p>In theory, answers to questions in the vein of \"Why is it done this way?\" belong in this section.</p>"},{"location":"architecture/#minimize-the-interface-with-v8","title":"Minimize the interface with V8","text":"<p>V8 is extremely complex and is under continual, heavy development. Such development can result in interface changes, which may in turn break PyMiniRacer.</p> <p>To mitigate the risk of breakage with new V8 builds, we seek to minimize the \"API surface area\" between PyMiniRacer and V8. This means we seek to limit \"advanced\" use of both:</p> <ol> <li>The V8 C++ API, and</li> <li>The V8 build system (GN) and build options.</li> </ol> <p>Our success at minimizing the interface with the V8 build system can be measured by:</p> <ol> <li>The number of times the text <code>v8::</code> appears in <code>src/v8_py_frontend</code>, and</li> <li>The length of <code>builder/v8.build.py</code> (467 lines as of this writing!). Making V8 build    on multiple platforms takes a lot of trickery...</li> </ol>"},{"location":"architecture/#build-v8-from-source","title":"Build V8 from source","text":"<p>The V8 project does not produce stable binary distributions, i.e., static or dynamic libraries. (In Linux terms, this would probably look like dpkgs and rpms with names like <code>libv8</code> and <code>libv8-dev</code>.) Instead, any project (like NodeJS, Chromium, or... PyMiniRacer!) which wants to integrate V8 must first build it.</p>"},{"location":"architecture/#build-pypi-wheels","title":"Build PyPI wheels","text":"<p>Because V8 takes so long to build (about 2-3 hours at present on the free GitHub Actions runners), we want to build wheels for PyPI. We don't want folks to have to build V8 when they <code>pip install mini-racer</code>!</p> <p>We build wheels for many operating systems and architectures based on popular demand via GitHib issues. Currently the list is <code>{x86_64, aarch64} \u00d7 {Debian Linux, Alpine Linux, Mac, Windows}</code>.</p>"},{"location":"architecture/#use-the-free-github-actions-hosted-runners","title":"Use the free GitHub Actions hosted runners","text":"<p>PyMiniRacer is not a funded project, so we run on the free GitHub Actions hosted runners. These currently let us build for many key platforms.</p> <p>This also lets contributors easily run the same build automation by simply forking the PyMiniRacer repo and running the workflows (for free!) within their own forks.</p>"},{"location":"architecture/#dont-interface-with-the-cpython-api-dont-make-an-extension","title":"Don't interface with the CPython API (don't make an extension)","text":"<p>We'd rather avoid directly interfacing with the CPython API, for a couple reasons:</p> <ol> <li>API flux: Similar to the above note about V8, the CPython API is complex and    always in flux, although not as much as V8).</li> <li>Version proliferation: there are a ton of active Python versions (as of this    writing, PyMiniRacer supports 3.8, 3.9, 3.10, 3.11, and 3.12, and also there's    CPython and PyPy). PyMiniRacer already includes builds for 7 target architectures    (see above); if we factor in 5x Python versions and 2x Python interpreters, we will    wind up with 70 wheels, all on a free GitHub Actions runner!</li> </ol> <p>So, instead of an extension module (which includes <code>Python.h</code> and links against <code>libpython</code>), we build an ordinary Python-independent C++ library, and use <code>ctypes</code> to access it.</p> <p>Consequently, <code>libmini_racer.so</code> isn't specific to Python, and the code barely mentions Python. One could in theory use it from any other language which knows how to call C APIs, such as Java, Go, C#, ... or just C. No one does so as of this writing.</p>"},{"location":"architecture/#dont-use-cibuildwheel","title":"Don't use <code>cibuildwheel</code>","text":"<p>Many modern Python projects which need to build wheels with native code use the <code>cibuildwheel</code> project to manange their builds. However, <code>cibuildwheel</code> isn't a perfect fit here. Because we are building Python-independent dynamic-link libraries instead of Python extension modules modules for the reasons noted above, we aren't linking with any particular Python ABI. Thus we need only <code>(operating systems \u00d7 architectures)</code> builds, whereas <code>cibuildwheel</code> generates <code>(operating systems \u00d7 architecture \u00d7 Python flavors \u00d7 Python versions)</code> wheels. That's a ton of wheels! Given that it takes hours to days to build PyMiniRacer for one target OS and architecture, doing redundant builds is undesirable.</p> <p>It might be possible to use <code>cibuildwheel</code> with PyMiniRacer by segmenting the build of the dynamic-link library (i.e., <code>libmini_racer.so</code>) from the actual wheel build. That is, we could have the following separate components:</p> <ol> <li>Create a separate Github Actions workflow to build the <code>libmini_racer.so</code> binary    (i.e., the hard part). Publish that as a release, using the GitHub release artifact    management system as a distribution mechanism.</li> <li>The wheel build step could then simply download a pre-built binary from the latest    GitHub release. We could use <code>cibuildwheel</code> to manage this step. This would generate    many redundant wheels (because the wheels we'd generate for, say, CPython 3.9 and    3.10 would be identical), but it wouldn't matter because it would be cheap and    automatic.</li> </ol> <p>This is similar to how the Ruby <code>mini_racer</code> and <code>libv8-node</code> projects, which inspired PyMiniRacer, work together today.</p> <p>To sum up, to use <code>cibuildwheel</code>, we would still need our own separate multi-architecture build workflow for V8, ahead of the <code>cibuildwheel</code> step. So <code>cibuildwheel</code> could potentially simplify the actual wheel distribution for us, but it wouldn't simplify the overall workflow management.</p>"},{"location":"architecture/#build-with-cross-compile-for-aarch64-on-linux-and-windows","title":"Build with cross-compile for aarch64 on Linux and Windows","text":"<p>Trial and error indicates the V8 build process is simply not geared to be run on an actual Linux or Windows Arm machine. Various parts of the build system keep trying to run x86_64 tools (like a pre-built clang or rustc). On the other hand, cross-compiling works very well out of the box, so we do that!</p> <p>This doesn't apply on MacOS which has good native MacOS support on Arm, since that's obviously what many or most developers are using.</p>"},{"location":"architecture/#build-for-alpine-as-a-cross-compatible-glibc-binary","title":"Build for Alpine as a cross-compatible glibc binary","text":"<p>Prior versions of PyMiniRacer build V8 natively on Alpine, using a series of hacks and patches.</p> <p>This seems to be hopeless today; there are just too many parts of the V8 build which are incompatible with Alpine (and assume that \"Linux\" means \"glibc\"). Both the clang and rustc configuration systems are hard-wired in many ways that preclude operation on Alpine without extensive patching (or just dispensing with the V8 build system entirely!).</p> <p>So instead we build a on Ubuntu with glibc and then put that into a wheel on Alpine. To use the resulting wheel, you must <code>apk add gcompat libgcc</code> and add the environment variable <code>LD_PRELOAD=\"/lib/libgcompat.so.0\"</code>.</p>"},{"location":"architecture/#build-v8-with-our-frontend-v8_py_frontend-as-a-snuck-in-component","title":"Build V8 with our frontend (<code>v8_py_frontend</code>) as a snuck-in component","text":"<p>We could just get a static library (i.e., <code>libv8.a</code>) from the V8 build, and link that into a dynamic-link library (i.e., <code>libmini_racer.so</code>) ourselves.</p> <p>However:</p> <ol> <li>We do have more C++ files to compile (the C++ code in <code>src/v8_py_frontend</code>)</li> <li>Because we're not making a true Python extension module (see above), we aren't using    Python's <code>setuptools</code> <code>Extension</code> infrastructure to perform a build.</li> </ol> <p>This leaves us needing some platform-independent C++ toolchain.</p> <p>V8 already has such a toolchain, based on Ninja and Generated Ninja files (GN). We already have to set it up to build V8 from source (see above for why!).</p> <p>Rather than bringing in yet another toolchain, we sneak <code>v8_py_frontend</code> into the V8 tree itself, as a \"custom dep\". We then instruct GN to build it as if it were an ordinary part of V8.</p> <p>The result is a dynamic-link library which contains an ordinary release build of V8, plus our Python <code>ctypes</code>-friendly frontend.</p>"},{"location":"architecture/#buggy-or-adversarial-javascript-shouldnt-be-able-to-crash-or-otherwise-disrupt-things","title":"Buggy or adversarial JavaScript shouldn't be able to crash or otherwise disrupt things","text":"<p>Per the security goals above, we want PyMiniRacer to be able to run untrusted JavaScript code safely. This means we can't trust JavaScript to \"behave\". Intentionally bad (i.e, adversarial) or unintentionally bad (i.e., buggy) JavaScript should not be able to:</p> <ol> <li>Crash PyMiniRacer,</li> <li>Read arbitrary memory, or</li> <li>Use infinite CPU or memory resources</li> </ol> <p>For the latter, the PyMiniRacer Python API exposes optional constraints on memory usage as well as timeouts. The former two rules are enforced by the design of the C++ side of PyMiniRacer, and of course V8 itself.</p>"},{"location":"architecture/#dont-trust-javascript-with-memory-management-of-c-objects","title":"Don't trust JavaScript with memory management of C++ objects","text":"<p>JavaScript is a garbage-collected language, and like many such languages it offers best-effort finalizer functionality, into which you can inject code which gets called when the runtime is disposing of an object.</p> <p>However, with V8-based JavaScript, actually relying on this functionality to trigger callbacks to C++ to clean things up is heartily discouraged. Exploratory attempts to make this with PyMiniRacer actually didn't work at all.</p> <p>Even if we could get V8 to call us back reliably to tear down objects (e.g., by exposing an explicit teardown function to JavaScript), it would be hard to create a design which does so safely. V8 (per our security goals) may be running adversarial JavaScript which might try and use a reference after we free it, exploiting a use-after-free bug.</p>"},{"location":"architecture/#any-raw-c-object-pointers-and-references-given-to-javascript-must-outlive-the-v8isolate","title":"Any raw C++ object pointers and references given to JavaScript must outlive the <code>v8::Isolate</code>","text":"<p>Due to the above rule, we can't rely on V8 to tell us when it's done with any references we give it, until the <code>v8::Isolate</code> is torn down. So clearly the only thing we can do is ensure any raw pointers or references we hand to V8 are valid until after the <code>v8::Isolate</code> is torn down.</p>"},{"location":"architecture/#use-javascript-integer-ids-to-track-any-allocated-objects-on-the-c-side","title":"Use JavaScript integer IDs to track any allocated objects on the C++ side","text":"<p>The above said, we still have cases where we want to tell JavaScript about objects which have shorter lifecycles than the <code>v8::Isolate</code> itself. E.g., a function callback from JavaScript to C++ (and thus to Python) might only be used as a single <code>Promise.then</code> callback. If a long-running program were to create tons of <code>Promise</code>s, we'd want to garbage collect the callbacks as we go, without waiting for the whole <code>v8::Isolate</code> to exit.</p> <p>We can treat that case by \"laundering\" our raw C++ pointers and references through C++ maps (i.e., <code>std::unordered_map&lt;uint64_t, std::shared_ptr&lt;T&gt;&gt;</code>), giving V8 JavaScript only IDs into the map. We can convert IDs back into C++ pointers when JavaScript calls us back, after checking that they're still valid. (And we use <code>std::shared_ptr</code> to avoid tear-down race conditions wherein a map entry is removed in one thread while we're still using an object in another.)</p> <p>In this manner, the C++ side can be authoritative about when objects are torn down. It can delete C++ objects and remove them from the map whenever it sees fit. If JavaScript tries to use the ID after that point, such usage can be easily spotted and safely ignored.</p>"},{"location":"architecture/#buggy-python-shouldnt-be-able-to-crash-c","title":"Buggy Python shouldn't be able to crash C++","text":"<p>Similar to, but with a lower priority than the above rule regarding bad JavaScript, bad Python should not be able to crash the Python interpretter through PyMiniRacer. This is a common design principle for Python; bad code should not result in segmentation faults, sending developers scrambling to C/C++ debugging of core files, etc. Extension modules should uphold this principle.</p> <p>This applies only to unintentionally bad (i.e., buggy) Python code. PyMiniRacer does not and cannot protect itself from intentionally bad (i.e., adversarial) Python code. A determined Python programmer can always crash Python with ease without any help from PyMiniRacer. Try it!: <code>import ctypes; ctypes.cast(0x1, ctypes.c_char_p).value</code></p>"},{"location":"architecture/#minimize-trust-of-python-in-automatic-memory-management-of-c-objects","title":"Minimize trust of Python in automatic memory management of C++ objects","text":"<p>Python is also a garbage-collected language, and like JavaScript, it offers best-effort finalizer functionality.</p> <p>Like in JavaScript code, relying on Python's finalizer functionality is heartily discouraged. We can, at best, use <code>__del__</code> as a shortcut signaling we can go ahead and free something to help reduce memory usage, but we shouldn't rely on it.</p> <p>Since, unlike JavaScript, we do trust Python code, we can create explicit Python APIs to manage object lifecycle. The Pythonic way to do that is with context managers.</p> <p>Thus, for example, the MiniRacer Python <code>_Context</code> object, which wraps exactly one C++ <code>MiniRacer::Context</code> object, provides both a <code>__del__</code> finalizer for easy cleanup which always works \"eventually\", and an explicit context manager interface for PyMiniRacer users who want strong guarantees about teardown.</p>"},{"location":"architecture/#minimize-trust-of-python-in-handing-cc-pointers","title":"Minimize trust of Python in handing C/C++ pointers","text":"<p>The <code>ctypes</code> module lets Python directly wrangle C/C++ pointers. This can be used to send, receive, and mutate data shared between Python and C.</p> <p>This is obviously somewhat dangerous. Array overruns are an obvious problem. Use-after-free is more insidious: imagine the C++ side of PyMiniRacer returns a pointer to an object to Python, Python stores that pointer, the C++ frees the object, and then Python tries to use the pointer. This will work sometimes and crash\u2014or worse, read incorrect data\u2014at other times.</p>"},{"location":"architecture/#use-python-integer-ids-to-track-any-allocated-objects-on-the-c-side","title":"Use Python integer IDs to track any allocated objects on the C++ side","text":"<p>Thus, combining all the above rules, we wind up with a similar rule for Python as we have for JavaScript. Wherever possible, we avoid interchanging raw pointers between C++ and Python. Instead, we interchange integer IDs. The C++ side of PyMiniRacer can convert integer IDs to raw pointers using a map, after validating that the IDs are still valid.</p>"},{"location":"architecture/#except-for-valuehandle-pointers","title":"... except for <code>ValueHandle</code> pointers","text":"<p>We break the above rule for <code>ValueHandle</code> pointers. PyMiniRacer uses <code>ValueHandle</code> to exchange most data between Python and C++. Python directly reads the contents of <code>ValueHandle</code> pointers, to read primitive values (e.g., booleans, integers, and strings).</p> <p>We do this for theoretical performance reasons which have not yet been validated. To be consistent with the rest of PyMiniRacer's design, we could create an API like:</p> <ol> <li>C++ generates a numeric <code>value_id</code> and stores a Value in a    <code>std::unordered_map&lt;uint64_t, std::shared_ptr&lt;Value&gt;&gt;</code>.</li> <li>C++ gives Python that <code>value_id</code> to Python.</li> <li>To get any data Python has to call APIs like <code>mr_value_type(context_id, value_id)</code>,    <code>mr_value_as_bool(context_id, value_id)</code>,    <code>mr_value_as_string_len(context_id, value_id)</code>,    <code>mr_value_as_string(context_id, value_id, buf, buflen)</code>, ...</li> <li>Eventually Python calls <code>mr_value_free(context_id, value_id)</code> which wipes out the map    entry, thus freeing the <code>Value</code>.</li> </ol> <p>**Note: We don't do this. The above is _not how PyMiniRacer actually handles values.**_</p> <p>This is surely slower than direct pointer access, but no performance analysis has been done to see if it matters. It might be interesting to try the above and benchmark it. It would be nice to switch to that model if it's sufficiently performant.</p> <p>For now at least, we instead use raw pointers for this case.</p> <p>We still don't fully trust Python with the lifecyce of <code>ValueHandle</code> pointers; when Python passes these pointers back to C++, we still check validity by looking up the pointer as a key into a map (which then lets the C++ side of PyMiniRacer find the rest of the <code>Value</code> object). The C++ <code>MiniRacer::ValueFactory</code> can authoritatively destruct any dangling <code>Value</code> objects when it exits.</p> <p>This last especially helps with an odd scenario introduced by Python <code>__del__</code>: the order in which Python calls <code>__del__</code> on a collection of objects is neither guaranteed nor very predictable. When a Python program drops references to a Python <code>MiniRacer</code> object, it's common for Python to call <code>_Context.__del__</code> before it calls <code>ValHandle.__del__</code>, thus destroying the container for the value before it destroys the value itself. The C++ side of PyMiniRacer can easily detect this scenario: First, when destroying the <code>MiniRacer::Context</code>, it sees straggling <code>Value</code>s and destroys them. Then, when Python asks C++ to destroy the straggling <code>ValueHandle</code>s, the C++ <code>mr_free_value</code> API sees the <code>MiniRacer::Context</code> is already gone, and ignores the redundant request.</p> <p>The above scenario does imply a possibility for dangling pointer access: if Python calls <code>_Context.__del__</code> then tries to read the memory addressed by the raw <code>ValueHandle</code> pointers, it will be committing a use-after-free error. We mitigate this problem by hiding <code>ValueHandle</code> within PyMiniRacer's Python code, and by giving <code>ValHandle</code> (our Python wrapper of <code>ValueHandle</code>) a reference to the <code>_Context</code>, preventing the context from being finalized until the <code>ValHandle</code> is also in Python's garbage list and on its way out.</p>"},{"location":"architecture/#only-touch-most-of-the-v8isolate-from-within-the-message-loop","title":"Only touch (most of) the <code>v8::Isolate</code> from within the message loop","text":"<p>While a <code>v8::Isolate</code> is generally a thread-aware and multi-threaded object, most of its methods are not thread-safe. The same goes for most <code>v8</code> objects. It is, generally, only safe to touch things belonging to a <code>v8::Isolate</code> if you hold the <code>v8::Locker</code> lock. (To make matters more interesting, documentation about what things might be safe to do without the lock is pretty scarce. You find out when your unsafe code crashes. Which, you know, might not happen until years after you wrote the unsafe code. C++ is fun!)</p> <p>The \"don't touch the <code>v8::Isolate</code> without holding the <code>v8::Locker</code>\" rule is made particularly hard to follow since we also need to run a message loop thread to service background work in v8. That message loop, of course, itself needs the <code>v8::Locker</code>. Unfortunately, the message loop can wait indefinitely for new work, and yet doesn't give up the lock while doing that waiting.</p> <p>This poses a conundrum: the message loop hogs the isolate lock potentially indefinitely, and yet other threads (i.e., Python threads) need that lock so they can poke at <code>v8::Isolate</code>-owned objects too.</p> <p>We resolve the conundrum by leveraging part of the <code>v8::Isolate</code> itself, using a trick similar to what NodeJS does: everything that needs to touch a <code>v8::Isolate</code> should simply run from the <code>v8::Isolate</code>'s own message loop. If you want to run JS code, manipulate an object, or even delete a V8 object, you must submit a task to the message loop. Then nothing but the message loop itself should need to hold the <code>v8::Locker</code> lock, because only the message loop ever touches the <code>v8::Isolate</code>.</p> <p>To make this somewhat easier we have created <code>MiniRacer::IsolateManager</code>, which provides an easy API to submit tasks, whose callbacks accept as their first-and-only argument a <code>v8::Isolate*</code>. Such tasks can freely work on the isolate until they exit. (Obviously, saving a copy of the pointer and using it later would defeat the point; don't do that.)</p> <p>One odd tidbit of PyMiniRacer is that even object destruction has to use the above pattern. For example, it is (probably) not safe to free a <code>v8::Global</code> without holding the isolate lock, so when a non-message-loop thread needs to destroy a wrapped V8 value, we enqueue a pretty trivial task for the message loop: <code>isolate_manager-&gt;Run([global]() { delete global; })</code>.</p> <p>See here for some discussion of this design on the v8-users mailing list.</p>"},{"location":"architecture/#if-any-c-code-creates-an-isolate-task-its-responsible-for-awaiting-its-completion-before-teardown","title":"If any C++ code creates an Isolate task, it's responsible for awaiting its completion before teardown","text":"<p>The pattern, described above\u2014of enqueuing all kinds of tasks for the v8 message pump, including object destruction work\u2014creates an interesting memory management problem for PyMiniRacer. Such tasks typically create a reference cycle: the creator of the task (like, say, the <code>MiniRacer::Context::MakeJSCallback</code>) bundles into the task references to various other objects including, often, <code>this</code>. Those objects often themselves contain references to the <code>MiniRacer::IsolateManager</code>, which transitively contains a reference to the <code>v8::Isolate</code> and its message queue. Since the message queue contains a reference to the task, we've just created a reference cycle!</p> <p>To avoid either use-after-free or memory leak bugs upon teardown of a <code>MiniRacer::Context</code>, we must enforce the following rule:</p> <p>If you call <code>MiniRacer::IsolateManager::Run(xyz)</code>, you are reponsible for ensuring that task is done before any objects you bound into the function closure xyz (including and especially <code>this</code>) are destroyed.</p> <p>The most common way we ensure this is waiting on the <code>std::future&lt;void&gt;</code> returned by <code>MiniRacer::IsolateManager::Run(xyz)</code>. When that future settles, the task is done, and it's safe to continue tearing down any references the task may hold.</p>"},{"location":"authors/","title":"Credits","text":""},{"location":"authors/#authors","title":"Authors","text":"<ul> <li>Jean-Baptiste AVIAT jb@sqreen.com</li> <li>Boris FELD boris@sqreen.com</li> <li>Selim MENOUAR selim@sqreen.com</li> <li>Nicolas VIVET nicolas@sqreen.com</li> </ul>"},{"location":"authors/#contributors","title":"Contributors","text":"<ul> <li>messense https://github.com/messense</li> <li>Ben Creech https://github.com/bpcreech</li> </ul> <p>Why not add your name to the list?</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":"<p>You can contribute in many ways:</p>"},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/bpcreech/PyMiniRacer/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"feature\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>Python Mini Racer could always use more documentation, whether as part of the official Python Mini Racer docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/bpcreech/PyMiniRacer/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome   :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>PyMiniRacer</code> for local development.</p> <p>Warning</p> <p>1-2 hours.</p> <ol> <li> <p>Do a quick scan through the architecture guide before diving in.</p> </li> <li> <p>Fork the <code>PyMiniRacer</code> repo on GitHub.</p> </li> <li> <p>If you plan to change C++ code you should probably install at least <code>clang-format</code>    and <code>clang-tidy</code> from the latest stable LLVM. While the    <code>PyMiniRacer</code> build uses its own compiler (!) on most systems, our pre-commit rules    rely on the system <code>clang-format</code> and <code>clang-tidy</code>. If your versions of those    utilities do not match the ones <code>PyMiniRacer</code> uses on GitHub Actions, you may see    spurious pre-commit errors.</p> <p>If you're on a Debian-related Linux distribution using the LLVM project's standard apt packages, note that you will likely have to override <code>/usr/bin/clang-format</code> and <code>/usr/bin/clang-tidy</code> to point to the latest version, i.e., <code>/usr/bin/clang-format-18</code> and <code>/usr/bin/clang-tidy-18</code>, respectively.</p> <p>You can always silence local pre-commit errors with the <code>-n</code> argument to <code>git commit</code>. We check <code>pre-commit</code>s on every pull request using GitHub Actions, so you can check for errors there instead.</p> </li> <li> <p>Install just.</p> </li> <li> <p>Install uv.</p> </li> <li> <p>Run some of the following:</p> <pre><code>    # Set up a local clone of your fork:\n    $ git clone git@github.com:your_name_here/PyMiniRacer.git\n    $ cd PyMiniRacer/\n\n    # build v8 and uv (this may take hours depending on your system!)\n    $ just build\n    # alternatively, to only build v8 and skip making the Python package:\n    $ uv run --no-project builder/v8_build.py  # will install a DLL into src/py_mini_racer\n\n    # test stuff:\n    $ uv run pytest test\n\n    # fix and lint any changes you make:\n    $ just fix\n    $ just lint\n</code></pre> <p>You can also play with your build in the Python REPL, as follows:</p> <pre><code>    $ uv run python\n    &gt;&gt;&gt; from py_mini_racer import MiniRacer\n    &gt;&gt;&gt; mr = MiniRacer()\n    &gt;&gt;&gt; mr.eval('6*7')\n    42\n    &gt;&gt;&gt; exit()\n    $ exit\n</code></pre> </li> <li> <p>Create a branch for local development::</p> <pre><code>    $ git checkout -b feature/name-of-feature\n    # or:\n    $ git checkout -b fix/name-of-fix\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass the linter and the    tests, including testing other Python versions:</p> <pre><code>   # automatically fix any trivial linting issues:\n   $ just fix\n   # check for remaining linting issues:\n   $ just lint\n   # if you changed C++ code, lint it (this takes a long time):\n   $ just clang-tidy\n   # look at the docs if you changed them:\n   $ just serve-docs\n   # build v8, and your change (this takes a long time):\n   $ just build\n   # test:\n   $ just test\n   $ just test-matrix\n</code></pre> </li> <li> <p>Commit your changes and push your branch to GitHub::</p> <pre><code>   $ git add .\n   $ git commit -m \"Your detailed description of your changes.\"\n   $ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>(Optional) Run the GitHub Actions build workflow on your fork to ensure that all    architectures work.</p> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated. Put your new    functionality into a function with a docstring, and add the feature to the list in    README.md.</li> <li>The pull request should work for the entire test matrix of Python versions    (<code>just test-matrix</code>).</li> </ol>"},{"location":"contributing/#releasing-pyminiracer","title":"Releasing <code>PyMiniRacer</code>","text":"<p>Releases for <code>PyMiniRacer</code> should be done by GitHub Actions on the official project repository.</p>"},{"location":"contributing/#ordinary-releases","title":"Ordinary releases","text":"<p>To make an ordinary release from <code>main</code>:</p> <ol> <li> <p>Merge all changes into <code>main</code> on the official repository.</p> </li> <li> <p>Pick the next revision number:</p> <pre><code>$ git fetch\n$ git ls-remote origin | grep refs/heads/release\n# observe the next available release version\n</code></pre> </li> <li> <p>Create a <code>feature/...</code> branch, and:</p> <ol> <li> <p>Update <code>HISTORY.md</code> with a summary of changes since the last release.</p> </li> <li> <p>Update <code>src/py_mini_racer/__about__.py</code> with the new revision number.</p> </li> <li> <p>Create and merge a pull request for this branch into <code>main</code>.</p> </li> </ol> </li> <li> <p>Create a <code>release/...</code> branch:</p> <pre><code>$ git checkout main\n$ git pull\nNEXT_RELEASE=the next tag, starting with the letter v. E.g., \"v0.12.1\".\n$ git checkout -b \"release/${NEXT_RELEASE}\"\n$ git push --set-upstream origin \"release/${NEXT_RELEASE}\"\n</code></pre> </li> <li> <p>Observe the build process on GitHub Actions. It should build and push docs and upload    wheels to PyPI automatically.</p> </li> </ol>"},{"location":"contributing/#hotfix-releases","title":"Hotfix releases","text":"<p>To hotfix a prior release:</p> <ol> <li> <p>Prepare the fix as a <code>feature</code> branch as normal, and merge it into <code>main</code>.</p> </li> <li> <p>Pick the next revision number. This will typically be a patch-version update on the    current release name.</p> </li> <li> <p>Create a new release branch for the hotfix:</p> <pre><code>BASE_RELEASE=the release you are hotfixing, starting with the letter v. E.g., \"v0.12.0\".\nNEXT_RELEASE=the next tag, starting with the letter v. E.g., \"v0.12.1\".\n$ git checkout \"release/${BASE_RELEASE}\"\n$ git pull\n$ git checkout -b \"release/${NEXT_RELEASE}\"\n</code></pre> </li> <li> <p>Hotfix the commit(s) created in step #1 onto the new release branch.</p> </li> <li> <p>Create a version update commit:</p> <ol> <li> <p>Update <code>HISTORY.md</code> with a summary of changes since the last release.</p> </li> <li> <p>Update <code>src/py_mini_racer/__about__.py</code> with the new revision number.</p> </li> </ol> </li> <li> <p>Commit and push the new release branch to GitHub.</p> </li> <li> <p>Merge this branch into <code>main</code>. All content on release branches should be included in    <code>main</code>.</p> </li> <li> <p>Observe the build process on GitHub Actions. It should build and push docs and upload    wheels to PyPI automatically.</p> </li> </ol>"},{"location":"history/","title":"History","text":""},{"location":"history/#0141-2026-01-31","title":"0.14.1 (2026-01-31)","text":"<ul> <li>Fix memory leak when tracking JS objects in Python. We were never calling   v8::Persistent::Reset(). Now we use v8::Global which has no such requirement.</li> <li>In the C++ implementation, rename BinaryValue to just Value and optimize things a bit   by collapsing various data members into a Variant.</li> <li>Upgrade to V8 14.4 from 14.3.</li> </ul>"},{"location":"history/#0140-2026-01-03","title":"0.14.0 (2026-01-03)","text":"<ul> <li>Major revamp of Python-side async handling: <code>PyMiniRacer</code> now manages most   asynchronous work (in particular, cancelable work) through an <code>asyncio</code> event loop.   This is intended to make <code>PyMiniRacer</code> easier to reason about, removing opportunities   for deadlocks and race conditions.</li> <li>We expose new async methods for function evaluation which unblock the event loop for   long calculations while honoring standard <code>asyncio</code> task cancellation semantics.</li> <li>To improve determinism during teardown, we expose and strongly recommend a new context   manager, <code>mini_racer</code> to more explicitly create and tear down <code>MiniRacer</code> instances.</li> </ul>"},{"location":"history/#0132-2025-12-25","title":"0.13.2 (2025-12-25)","text":"<ul> <li>Improve performance of function calls by exposing Array.prototype.push (avoiding two   round trips to get array size and then slice it, for function call argv construction).</li> <li>Various internal simplifications intended to improve maintainability. None of these   should be externally visible.</li> </ul>"},{"location":"history/#0131-2025-12-24","title":"0.13.1 (2025-12-24)","text":"<ul> <li>Fix MacOS wheels to not require MacOS 15.</li> </ul>"},{"location":"history/#0130-2025-12-07","title":"0.13.0 (2025-12-07)","text":"<ul> <li>Upgrade to V8 14.3 from 12.6.</li> <li>Add Windows Arm support!</li> <li>Alpine support is now reduced to using <code>gcompat</code> and   <code>LD_PRELOAD=\"/lib/libgcompat.so.0\"</code>.</li> <li>Crank up strictness of ruff and mypy, fixing uncovered typing issues.</li> <li>Internally: Switch from Hatch and pre-commit to uv, Justfile, and Prettier.</li> <li>Internally: Cross compile for arm (testing on the new native Github runners!) instead   of using emulation + sccache. This cuts the build time about 10x!</li> </ul>"},{"location":"history/#0124-2024-06-16","title":"0.12.4 (2024-06-16)","text":"<ul> <li>Upgrade to V8 12.6 from 12.4.</li> </ul>"},{"location":"history/#0123-2024-05-25","title":"0.12.3 (2024-05-25)","text":"<ul> <li>Fix potential hang if JavaScript calls a function produced by <code>wrap_py_function</code> while   we're tearing it down.</li> </ul>"},{"location":"history/#0122-2024-05-20","title":"0.12.2 (2024-05-20)","text":"<ul> <li> <p>Add optional context manager and <code>.close()</code> semantics to Python <code>MiniRacer</code> class.</p> </li> <li> <p>Fixed a potential hang on MiniRacer teardown if MiniRacer is executing a microtask   which loops infinitely.</p> </li> <li> <p>Switch C++ side of MiniRacer to a more straightforward object lifecycle management   model.</p> </li> </ul>"},{"location":"history/#0121-2024-05-18","title":"0.12.1 (2024-05-18)","text":"<ul> <li>Update to V8 12.4. This includes fixes for CVE-2024-3159, CVE-2024-3156, and   CVE-2024-2625. These vulnerabilities in V8 would impact PyMiniRacer users who are   running untrusted and adversarial JavaScript code.</li> </ul>"},{"location":"history/#0120-2024-04-29","title":"0.12.0 (2024-04-29)","text":"<ul> <li> <p>Added support for installing callbacks from JS back into Python, using   MiniRacer.wrap_py_function.</p> </li> <li> <p>Refactored the Python implementation into many internal files. This should mostly not   present a breaking change, except for code which reaches into internal (<code>_</code>-prefixed)   variables.</p> </li> </ul>"},{"location":"history/#0111-2024-04-08","title":"0.11.1 (2024-04-08)","text":"<ul> <li> <p>Fixed Python crash on long-running microtasks, introduced in v0.8.1 (before which   long-running microtasks would probably not run at all).</p> </li> <li> <p>Fixed memory leak on the exception object reported when an <code>eval</code> times out.</p> </li> <li> <p>Hardened the memory management of JS value interchange, context tracking, and   asynchronous task tracking between C++ and Python.</p> </li> <li> <p>Added exhaustive typing (now with a MyPy pre-commit to verify!)</p> </li> <li> <p>Added a test asserting that the v8 sandbox is enabled   on all platforms we build wheels for.</p> </li> </ul>"},{"location":"history/#0110-2024-04-03","title":"0.11.0 (2024-04-03)","text":"<ul> <li> <p>Added a <code>MutableMapping</code> (<code>dict</code>-like) interface for all derivatives of JS Objects,   and a <code>MutableSequence</code> (<code>list</code>-like) interface for JS Arrays. You can now use   Pythonic idioms to read and write Object properties and Array elements in Python,   including recursively (i.e., you can read Objects embedded in other objects, and embed   your own).</p> </li> <li> <p>Added ability to directly call <code>JSFunction</code> objects from Python. E.g.,   <code>mr.eval(\"a =&gt; a*a\")(4)</code> parses the given number-squaring code into a function,   returns a handle to that function to Python, calls it with the number <code>4</code>, and   recieves the result of <code>16</code>.</p> </li> <li> <p>Added a <code>JSUndefined</code> Python object to model JavaScript <code>undefined</code>. This is needed to   properly implement the above interface for reading Object and Array elements.   Unfortunately, this may present a breaking change for users who assume JavaScript   <code>undefined</code> is modeled as Python <code>None</code>.</p> </li> <li> <p>Removed an old optimization for <code>eval</code> on simple no-argument function calls (i.e.,   <code>myfunc()</code>). The optimization only delivered about a 17% speedup on no-op calls (and   helped relatively less on calls which actually did work), and for the purpose of   optimizing repeated calls to the same function, it's now redundant with extracting and   calling the function from Python, e.g., <code>mr.eval(\"myfunc\")()</code>.</p> </li> <li> <p>Hardening (meaning \"fixing potential but not-yet-seen bugs\") related to freeing   <code>Value</code> instances (which convey data from C++ to Python).</p> </li> <li> <p>More hardening related to race conditions on teardown of the <code>MiniRacer</code> object in the   unlikely condition that <code>eval</code> operations are still executing on the C++ side, and   abandoned on the Python side, when Python attempts to garbage collect the <code>MiniRacer</code>   object.</p> </li> </ul>"},{"location":"history/#0100-2024-03-31","title":"0.10.0 (2024-03-31)","text":"<ul> <li> <p>Updated to V8 12.3 from V8 12.2 now that Chromium stable is on 12.3.</p> </li> <li> <p>Added Python-side support for JS Promises. You can now return a JS Promise from code   executed by <code>MiniRacer.eval</code>, and PyMiniRacer will convert it to a Python object which   has a blocking <code>promise.get()</code> method, and also supports <code>await promise</code> in <code>async</code>   Python functions.</p> </li> <li> <p>Added a <code>setTimeout</code> and <code>clearTimeout</code>. These common functions live in the Web API   standard, not the ECMAScript standard, and thus don't come with V8, but they're so   ubiquitious we now ship an implemention with <code>PyMiniRacer</code>.</p> </li> </ul>"},{"location":"history/#090-2024-03-30","title":"0.9.0 (2024-03-30)","text":"<ul> <li> <p>Revamped JS execution model to be out-of-thread. Python/C++ interaction now happens   via callbacks.</p> </li> <li> <p>Consequently, Control+C (<code>KeyboardInterrupt</code>) now interrupts JS execution.</p> </li> <li> <p>Hardened C++-side thread safety model, resolving potential race conditions introduced   in v0.8.1 (but not actually reported as happening anywhere).</p> </li> <li> <p>Further improved JS exception reporting; exception reports now show the offending code   where possible.</p> </li> <li> <p>Introduced <code>timeout_sec</code> parameter to <code>eval</code>, <code>call</code>, and <code>execute</code> to replace the   <code>timeout</code>, which unfortunately uses milliseconds (unlike the Python standard library).   In the future we may emit deprecation warnings for use of <code>timeout</code>.</p> </li> </ul>"},{"location":"history/#081-2024-03-23","title":"0.8.1 (2024-03-23)","text":"<ul> <li>A series of C++ changes which should not impact the behavior of PyMiniRacer:</li> <li>Refactoring how we use V8 by inverting the control flow. Before we had function   evaluations which ran and drained the message loop. Now we have an always-running   message loop into which we inject function evaluations. This seems to be the preferred   way to use V8. This is not expected to cause any behavior changes (but, in tests,   makes   microtask competion   more consistent).</li> <li>Refactoring the C++ implementation into multiple components to make startup and   teardown logic more robust.</li> <li>Added tests for the existing fast-function-call path.</li> <li>Also, simplified Python conversion of C++ evaluation results.</li> </ul>"},{"location":"history/#080-2024-03-18","title":"0.8.0 (2024-03-18)","text":"<ul> <li>General overhaul of C++ implementation to better adhere to modern best practice. This   should have no visible impact except for the following notes...</li> <li>Exposed the hard memory limit as a context-specific (as opposed to <code>eval</code>-specific)   limit, since that's how it worked all along anyway. The <code>max_memory</code> <code>eval</code> argument   still works for backwards compatibility purposes.</li> <li>Correct message type of some exceptions to <code>str</code> instead of <code>bytes</code> (they should all   be <code>str</code> now).</li> <li>Added better messages for JS parse errors.</li> <li>Added backtraces for more JS errors.</li> <li>Added some really basic Python typing.</li> </ul>"},{"location":"history/#070-2024-03-06","title":"0.7.0 (2024-03-06)","text":"<ul> <li>Update V8 to 12.2</li> <li>Drop Python 2 support</li> <li>Fix small Python 3.12 issue and add testing for Python 3.9-3.12</li> <li>Add aarch64 support for Mac and Linux</li> <li>Revamp DLL loading to be compliant with Python 3.9-style resource loading. This may   present a small breaking change for advanced usage; the <code>EXTENSION_PATH</code> and   <code>EXTENSION_NAME</code> module variables, and <code>MiniRacer.v8_flags</code> and <code>MiniRacer.ext</code> class   variable have all been removed.</li> <li>Add support for the ECMAScript internalization API and   thus the ECMA <code>Intl</code> API</li> <li>Use fast startup snapshots</li> <li>Switch from setuptools to Hatch</li> <li>Switch from tox to Hatch</li> <li>Switch from flake8 and isort to Hatch's wrapper of Ruff</li> <li>Switch from Sphinx to mkdocs (and hatch-mkdocs)</li> <li>Switch from unittest to pytest</li> <li>Add architecture.md and lots of code comments</li> </ul>"},{"location":"history/#060-2020-04-20","title":"0.6.0 (2020-04-20)","text":"<ul> <li>Update V8 to 8.9</li> <li>Optimize function calls without arguments</li> <li>Switch V8 to single threaded mode to avoid crashes after fork</li> <li>Switch to strict mode by default</li> <li>Revamp documentation</li> </ul>"},{"location":"history/#050-2020-02-25","title":"0.5.0 (2020-02-25)","text":"<ul> <li>Update V8 to 8.8</li> </ul>"},{"location":"history/#040-2020-09-22","title":"0.4.0 (2020-09-22)","text":"<ul> <li>Universal wheels for Linux, Mac and Windows</li> <li>Fallback to source package for Alpine Linux</li> </ul>"},{"location":"history/#030-2020-06-29","title":"0.3.0 (2020-06-29)","text":"<ul> <li>Introduce a strict mode</li> <li>Fix array conversion when size changes dynamically (CVE-2020-25489)</li> </ul>"},{"location":"history/#020-2020-03-11","title":"0.2.0 (2020-03-11)","text":"<ul> <li>Support for Alpine Linux</li> <li>Avoid pip private modules in setup.py</li> </ul>"},{"location":"history/#020b1-2020-01-09","title":"0.2.0b1 (2020-01-09)","text":"<ul> <li>Support for Windows 64 bits</li> <li>Support for Python 3.8</li> <li>Upgrade V8 to 7.8</li> <li>Support soft memory limits</li> </ul>"},{"location":"history/#0118-2019-01-04","title":"0.1.18 (2019-01-04)","text":"<ul> <li>Support memory and time limits</li> </ul>"},{"location":"history/#0117-2018-19-12","title":"0.1.17 (2018-19-12)","text":"<ul> <li>Upgrade libv8</li> <li>Fix a memory leak</li> </ul>"},{"location":"history/#0116-2018-07-11","title":"0.1.16 (2018-07-11)","text":"<ul> <li>Add wheel for Python without PyMalloc</li> </ul>"},{"location":"history/#0115-2018-06-18","title":"0.1.15 (2018-06-18)","text":"<ul> <li>Add wheel for Python 3.7</li> </ul>"},{"location":"history/#0114-2018-05-25","title":"0.1.14 (2018-05-25)","text":"<ul> <li>Add support for pip 10</li> <li>Update package metadata</li> </ul>"},{"location":"history/#0113-2018-03-15","title":"0.1.13 (2018-03-15)","text":"<ul> <li>Add heap_stats function</li> <li>Fix issue with returned strings containing null bytes</li> </ul>"},{"location":"history/#0112-2018-17-04","title":"0.1.12 (2018-17-04)","text":"<ul> <li>Remove dependency to enum</li> </ul>"},{"location":"history/#0111-2017-07-11","title":"0.1.11 (2017-07-11)","text":"<ul> <li>Add compatibility for centos6</li> </ul>"},{"location":"history/#0110-2017-03-31","title":"0.1.10 (2017-03-31)","text":"<ul> <li>Add the possibility to pass a custom JSON encoder in call.</li> </ul>"},{"location":"history/#019-2017-03-24","title":"0.1.9 (2017-03-24)","text":"<ul> <li>Fix the compilation for Ubuntu 12.04 and glibc &lt; 2.17.</li> </ul>"},{"location":"history/#018-2017-03-02","title":"0.1.8 (2017-03-02)","text":"<ul> <li>Update targets build for better compatibility with old Mac OS X and linux platforms.</li> </ul>"},{"location":"history/#017-2016-10-04","title":"0.1.7 (2016-10-04)","text":"<ul> <li>Improve general performances of the JS execution.</li> <li>Add the possibility to build a different version of V8 (for example with debug   symbols).</li> <li>Fix a conflict that could happens between statically linked libraries and dynamic   ones.</li> </ul>"},{"location":"history/#016-2016-08-12","title":"0.1.6 (2016-08-12)","text":"<ul> <li>Add error message when py_mini_racer sdist fails to build asking to update pip in   order to download the pre-compiled wheel instead of the source distribution.</li> </ul>"},{"location":"history/#015-2016-08-04","title":"0.1.5 (2016-08-04)","text":"<ul> <li>Build py_mini_racer against a static Python. When built against a shared library   python, it doesn't work with a static Python.</li> </ul>"},{"location":"history/#014-2016-08-04","title":"0.1.4 (2016-08-04)","text":"<ul> <li>Ensure JSEvalException message is converted to unicode</li> </ul>"},{"location":"history/#013-2016-08-04","title":"0.1.3 (2016-08-04)","text":"<ul> <li>Fix extension loading for python3</li> <li>Add a make target for building distributions (sdist + wheels)</li> <li>Fix eval conversion for python 3</li> </ul>"},{"location":"history/#012-2016-08-03","title":"0.1.2 (2016-08-03)","text":"<ul> <li>Fix date support</li> <li>Fix Dockerfile for generating python3 wheels</li> </ul>"},{"location":"history/#011-2016-08-02","title":"0.1.1 (2016-08-02)","text":"<ul> <li>Fix sdist distribution.</li> </ul>"},{"location":"history/#010-2016-08-01","title":"0.1.0 (2016-08-01)","text":"<ul> <li>First release on PyPI.</li> </ul>"}]}